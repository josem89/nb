{
    "isUpdateAvailable": true,
    "isCustom": false,
    "isEnabled": true,
    "isRemoteConnector": false,
    "environment": "Default Environment",
    "integration": "MicrosoftAzureSentinel",
    "identifier": "Microsoft Azure Sentinel Incident Connector v2_9cf3ff2b-8655-4343-8f2b-8755ae0bc6d3",
    "connectorDefinitionName": "Microsoft Azure Sentinel Incident Connector v2",
    "displayName": "Microsoft Azure Sentinel Incident Connector v2",
    "description": "Fetches Incidents from Azure Sentinel.",
    "runIntervalInSeconds": 30,
    "resultDataType": 0,
    "version": "1",
    "pythonVersion": 2,
    "isAllowlistSupported": false,
    "params": [
        {
            "connectorIdentifier": null,
            "paramName": "Script Timeout (Seconds)",
            "paramValue": "480",
            "description": "The timeout limit (in seconds) for the python process running current script",
            "type": 1,
            "mode": 0,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "Environment Field Name",
            "paramValue": "",
            "description": "Describes the name of the field where the environment name is stored. If environment field isn't found, environment is \"\".",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "Environment Regex Pattern",
            "paramValue": ".*",
            "description": "A regex pattern to run on the value found in the \"Environment Field Name\" field. Default is .* to catch all and return value unchanged. Used to allow the user to manipulate the environment field via regex logic. If regex pattern is null or empty, or the environment value is null, the final environment result is \"\".",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "Azure Subscription ID",
            "paramValue": "b29f15cb-eb34-4c3f-afbb-24552eee4613",
            "description": "Microsoft Azure Subscription ID, can be viewed in Azure Portal > Subscriptions > <Your Subscription> > Subscription ID. ",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "Azure Active Directory ID",
            "paramValue": "3f06a216-e798-47d3-9b06-31482aa5a648",
            "description": "Azure Active Directory Tenant ID, can be viewed in Active Directory > App Registration > <Application you configured for your integration> > Directory (tenant) ID.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "Alerts Padding Period",
            "paramValue": "60",
            "description": "Time frame in minutes to try to fetch alerts for incidents.",
            "type": 1,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "Scheduled Alerts Events Limit to Ingest",
            "paramValue": "100",
            "description": "Specify the maximum number of events the connector should ingest per a single Azure Sentinel Scheduled or NRT Alert.",
            "type": 1,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "Manager_ExtendedMicrosoftAzureSentinelManager",
            "paramValue": "import json\nimport uuid\nimport isodate\nimport requests\nfrom datetime import datetime, timedelta\nfrom MicrosoftAzureSentinelParser import MicrosoftAzureSentinelParser\nfrom MicrosoftAzureSentinelCommon import (\n    MicrosoftAzureSentinelCommon,\n    read_backlog_ids,\n    validate_backlog\n)\nfrom SiemplifyUtils import convert_string_to_datetime\nfrom datamodels import TagCollection, CustomHuntingRuleRequest\nfrom exceptions import (\n    MicrosoftAzureSentinelManagerError,\n    MicrosoftAzureSentinelValidationError,\n    MicrosoftAzureSentinelPermissionError,\n    MicrosoftAzureSentinelUnauthorizedError,\n    MicrosoftAzureSentinelBadRequestError,\n    MicrosoftAzureSentinelNotFoundError,\n    MicrosoftAzureSentinelTimeoutError,\n    MicrosoftAzureSentinelConflictError,\n)\nfrom urllib.parse import urljoin\nfrom utils import convert_list_to_comma_separated_string, LOGGER\nfrom enum import Enum\nfrom AzureQueryBuilder import QueryBuilder, Condition, QueryOperatorEnum, OperatorEnum\nfrom constants import ALERT_TYPES_WITH_EVENTS\n\n\nHEADERS = {\n    \"Content-Type\": \"application/json\"\n}\n# @TODO remove after refactor\nDEFAULT_API_VERSION = '2019-01-01-preview'\n\nLOGIN_ENDPOINT = \"/{}/oauth2/token\"\nTIME_FORMAT = \"%Y-%m-%dT%H:%M:%S.%fZ\"\nMIN_PT_DURATION = timedelta(minutes=5)\nMAX_PT_DURATION = timedelta(days=14)\n\n\nAPI_ENDPOINTS = {\n    'base_url': {\n       'url': '{api_root}/subscriptions/{subscriptions}/resourcegroups/{resource}'\n             '/providers/microsoft.operationalinsights/workspaces/{workspace}/'\n    },\n    'incidents': {\n        'url': 'providers/Microsoft.SecurityInsights/incidents',\n        'version': '2019-01-01-preview'\n    },\n    'incident_comments': {\n        'url': 'providers/Microsoft.SecurityInsights/incidents/{}/comments',\n        'version': '2022-07-01-preview'\n    },\n    'incident': {\n        'url': 'providers/Microsoft.SecurityInsights/Incidents/{incident_name}',\n        'version': '2019-01-01-preview'\n    },\n    'incident_comment': {\n        'url': 'providers/Microsoft.SecurityInsights/Incidents/{incident_number}/comments/{incident_comment_id}',\n        'version': '2019-01-01-preview'\n    },\n    'incident_cases': {\n        'url': 'providers/Microsoft.SecurityInsights/Cases',\n        'version': '2019-01-01-preview'\n    },\n    'INCIDENT_AGGREGATION': {\n        'URL': 'providers/Microsoft.SecurityInsights/aggregations/Cases',\n        'VERSION': '2019-01-01-preview'\n    },\n    'custom_hunting_rules_listing': {\n        'url': 'savedSearches',\n        'version': '2015-03-20'\n    },\n    'custom_hunting_rules': {\n        'url': 'savedSearches/{custom_hunting_rule_id}',\n        'version': '2015-03-20'\n    },\n    'alert_rules_listing': {\n        'url': 'providers/Microsoft.SecurityInsights/alertRules',\n        'version': '2019-01-01-preview'\n    },\n    'alert_rules': {\n        'url': 'providers/Microsoft.SecurityInsights/alertRules/{alert_rule_id}',\n        'version': '2019-01-01-preview'\n    },\n    'kql_query': {\n        'url': 'query',\n        'version': '2017-10-01',\n    },\n    'incident_aggregation': {\n        'url': 'providers/Microsoft.SecurityInsights/aggregations/Cases',\n        'version': '2019-01-01-preview'\n    },\n    'ping': {\n        'url': 'providers/Microsoft.SecurityInsights/incidents',\n        'version': '2019-01-01-preview'\n    },\n    'GET_INCIDENT_ALERTS': {\n        'URL': 'providers/Microsoft.SecurityInsights/incidents/{incident_name}/alerts',\n        'VERSION': '2019-01-01-preview'\n    },\n    'GET_ALERT_ENTITIES': {\n        'URL': 'providers/Microsoft.SecurityInsights/entities/{alert_id}/expand',\n        'VERSION': '2019-01-01-preview',\n        'DEFAULT_EXPANSION_ID': '98b974fd-cc64-48b8-9bd0-3a209f5b944b'\n    },\n    'GET_INCIDENT_ENTITIES': {\n        'URL': 'providers/Microsoft.SecurityInsights/Incidents/{incident_id}/entities',\n        'VERSION': '2019-01-01-preview'\n    }\n}\n\nADDITIONAL_DEFAULT_FOR_VALIDATION = ['Not Updated']\nCLOSED = 'Closed'\n\nDEFAULT_SEVERITIES = [\n    'Informational',\n    'Low',\n    'Medium',\n    'High',\n]\n\nDEFAULT_ALERT_RULE_SEVERITIES = [\n    'Informational',\n    'Low',\n    'Medium',\n    'High',\n]\n\nDEFAULT_STATUSES = [\n    'New',\n    'Active',\n    'Closed'\n]\n\nDEFAULT_UPDATE_INCIDENT_STATUSES = [\n    'Resolved',\n    'Dismissed',\n    'TruePositive',\n    'FalsePositive',\n    'Other'\n]\n\nDEFAULT_TRIGGER_OPERATORS = [\n    'GreaterThan',\n    'LessThan',\n    'Equal',\n    'NotEqual'\n]\n\nDEFAULT_CLOSE_REASONS = [\n    \"True Positive - suspicious activity\",\n    \"Benign Positive - suspicious but expected\",\n    \"False Positive - incorrect alert logic\",\n    \"False Positive - inaccurate data\",\n    \"Undetermined\"\n]\n\nCLOSE_REASON_DELIMITER = '-'\n\nDEFAULT_TACTICS = [\n    'InitialAccess',\n    'Execution',\n    'Persistence',\n    'PrivilegeEscalation',\n    'DefenseEvasion',\n    'CredentialAccess',\n    'Discovery',\n    'LateralMovement',\n    'Collection',\n    'Exfiltration',\n    'CommandAndControl'\n]\n\nDEFAULT_TIME_FRAME = 3\n\n\nclass QueryFilterKeyEnum(Enum):\n    ORDER_BY = '$orderBy'\n    LIMIT = '$top'\n    START_TIME = 'startTime'\n    END_TIME = 'endTime'\n    TIME_SPAN = 'timespan'\n    FILTER = '$filter'\n\n\nclass ExtendedMicrosoftAzureSentinelManager(object):\n    \"\"\"\n    MicrosoftAzureSentinel Manager\n    \"\"\"\n    def __init__(\n            self,\n            api_root,\n            client_id,\n            client_secret,\n            tenant_id,\n            workspace_id,\n            resource,\n            subscription_id,\n            login_url,\n            verify_ssl=False,\n            logger=None,\n            force_check_connectivity=False\n    ):\n        self.api_root = api_root\n        self.client_id = client_id\n        self.client_secret = client_secret\n        self.tenant_id = tenant_id\n        self.workspace_id = workspace_id\n        self.session = requests.Session()\n        self.session.verify = verify_ssl\n        self.session.headers = HEADERS\n        self.resource = resource\n        self.subscription_id = subscription_id\n        self.login_url = login_url\n        self.verify_ssl = verify_ssl\n        self.token = self.fetch_token()\n        self.session.headers.update({\"Authorization\": f'Bearer {self.token}'})\n        self.logger = LOGGER(logger)\n        self.sentinel_parser = MicrosoftAzureSentinelParser(self.logger)\n        self.sentinel_common = MicrosoftAzureSentinelCommon(self.logger)\n        self.base_url = self._get_base_url()\n\n        if force_check_connectivity:\n            self.test_connectivity()\n\n    @classmethod\n    def get_api_error_message(cls, exception):\n        \"\"\"\n        Get API error message\n        :param exception: {Exception} The api error\n        :return: {str} error message\n        \"\"\"\n        context = exception.response.content.decode()\n        try:\n            return exception.response.json().get('error', {}).get('message') or context\n        except:\n            return context\n\n    @classmethod\n    def validate_response(cls, response, error_msg='An error occurred'):\n        # type: (requests.Response, str) -> None\n        \"\"\"\n        Login Response Validation\n        @param response: API Response\n        @param error_msg: Error message to change raised one\n        \"\"\"\n        try:\n            response.raise_for_status()\n        except requests.HTTPError as error:\n            error_message = cls.get_api_error_message(error) or error_msg\n\n            if response.status_code == 429:\n                raise MicrosoftAzureSentinelTimeoutError(error_message)\n\n            if response.status_code == 504:\n                raise MicrosoftAzureSentinelManagerError(\n                    f\"Search didn't completed due to timeout. Error: {error_message}\")\n\n            if response.status_code == 409:\n                raise MicrosoftAzureSentinelConflictError(error_message)\n\n            if response.status_code == 404:\n                raise MicrosoftAzureSentinelNotFoundError(error_message)\n\n            if response.status_code == 403:\n                raise MicrosoftAzureSentinelPermissionError(error_message)\n\n            if response.status_code == 401:\n                raise MicrosoftAzureSentinelUnauthorizedError(error_message)\n\n            if response.status_code == 400:\n                raise MicrosoftAzureSentinelBadRequestError(error_message)\n\n            raise MicrosoftAzureSentinelManagerError(f'{error_msg}: {error} {error_message}')\n\n        if not response.ok:\n            raise\n\n    def _remove_session_header(self, header):\n        if self._has_session_header(header):\n            del self.session.headers[header]\n\n    def _add_session_header(self, header, value):\n        self.session.headers[header] = value\n\n    def _has_session_header(self, header):\n        return header in self.session.headers\n\n    def _get_base_url(self):\n        return self._get_endpoint_url(\n            url_id='base_url',\n            api_root=self.api_root,\n            subscriptions=self.subscription_id,\n            resource=self.resource,\n            workspace=self.workspace_id)\n\n    def test_connectivity(self):\n        try:\n            response = self.session.get(\n                self._get_full_url('ping'),\n                params={\n                    'api-version': self._get_endpoint_version('ping'),\n                    QueryFilterKeyEnum.LIMIT.value: 1\n                })\n            self.validate_response(response)\n        except Exception as e:\n            raise MicrosoftAzureSentinelManagerError(f'Failed to connect to the Azure Sentinel Workspace. Reason: {e}')\n\n    def fetch_token(self):\n        # type: () -> str\n        \"\"\"\n        Fetch authentication token for Devices payloads.\n        @return: Access token\n        \"\"\"\n        url = urljoin(self.login_url, LOGIN_ENDPOINT.format(self.tenant_id))\n        response = requests.post(\n            url,\n            data={\n                \"grant_type\": \"client_credentials\",\n                \"client_id\": self.client_id,\n                \"resource\": self.api_root,\n                \"client_secret\": self.client_secret\n            },\n            verify=self.verify_ssl\n        )\n        self.validate_login_response(response, \"Failed to connect to the Azure Sentinel Workspace\")\n        access_token = response.json().get('access_token')\n\n        if access_token:\n            return access_token\n\n        raise MicrosoftAzureSentinelManagerError(\"Failed fetching token. Error code: {}. Description: {}\".format(\n            response.status_code,\n            response.json().get(\"error_description\", response.content))\n        )\n\n    def _get_full_url(self, url_id, **kwargs):\n        \"\"\"\n        Get full url for session.\n        :param url_id: {str} The id of url\n        :param kwargs: {dict} Variables passed for string formatting\n        :return: {str} The full url\n        \"\"\"\n        url = urljoin(self.base_url, self._get_endpoint_url(url_id).format(**kwargs))\n\n        return url\n\n    def _get_endpoint_version(self, url_id):\n        \"\"\"\n        Get version for endpoint\n        :param url_id: {str} The id of url\n        :return: {str} Endpoint version\n        \"\"\"\n        return API_ENDPOINTS[url_id]['version']\n\n    def _get_endpoint_url(self, url_id, **kwargs):\n        \"\"\"\n        Get version for endpoint\n        :param url_id: {str} The id of url\n        :return: {str} Endpoint url\n        \"\"\"\n        url = API_ENDPOINTS[url_id]['url']\n        if kwargs:\n            return url.format(**kwargs)\n\n        return url\n\n    def get_alert_rules(self, severities=None, types=None, tactics=None, only_enabled_rules=False, limit=None):\n        # type: (list, list, list, bool, int) -> [object]\n        \"\"\"\n        Get all alert rules including filters\n        @param severities: Severities list of the alert rules to look for\n        @param types: Alert types\n        @param tactics: Alert rule tactics\n        @param only_enabled_rules: Only enabled alert rules\n        @param limit: returned alert rules count\n        @return: List of the alert rules\n        \"\"\"\n        url = self._get_full_url('alert_rules_listing')\n        params = {\n            'api-version': self._get_endpoint_version('alert_rules_listing')\n        }\n\n        response = self.session.get(url, params=params)\n        self.validate_response(response)\n        alert_rules_list = self.sentinel_parser.build_results(response.json(), 'build_siemplify_alert_rule_obj')\n\n        return self._filter_alert_rules(alert_rules_list, severities, types, tactics, only_enabled_rules, limit)\n\n    def get_alert_rule(self, alert_rule_id):\n        \"\"\"\n        Get alert rule by ID\n        @param alert_rule_id: ID of the alert rule\n        @return: {AlertRule} instance\n        \"\"\"\n        params = {\n            'api-version': self._get_endpoint_version('alert_rules')\n        }\n        response = self.session.get(self._get_full_url('alert_rules', alert_rule_id=alert_rule_id), params=params)\n        self.validate_response(response)\n\n        return self.sentinel_parser.build_siemplify_alert_rule_obj(response.json())\n\n    def create_alert_rule(self, enable_alert_rule, name, severity, query, frequency, lookup_period, trigger_operator,\n                          trigger_threshold, enable_suppression, suppression_duration, description=None, tactics=None):\n        # type: (bool, str, str, str, str, str, str, int, bool, str, str, list) -> object\n        \"\"\"\n        Create new alert rule\n        @param enable_alert_rule: Enables or Disables alert rule\n        @param name: Alert Rule name\n        @param severity: Alert Rule severity\n        @param query: Alert rule query\n        @param frequency: How frequently to run the query\n        @param lookup_period: Time of the last lookup data\n        @param trigger_operator: Alert Rule trigger operator\n        @param trigger_threshold: Alert Rule trigger threshold\n        @param enable_suppression: Whether you want to stop running query after alert is generated\n        @param suppression_duration: How long you want to stop running query after alert is generated\n        @param description: Alert Rule description\n        @param tactics: Alert Rule tactics\n        @return: New Alert Rule\n        \"\"\"\n        params = {\n            'api-version': self._get_endpoint_version('alert_rules')\n        }\n\n        json_payload = {\n            'properties': {\n                'enabled': enable_alert_rule,\n                'displayName': name,\n                'severity': severity,\n                'query': query,\n                'queryFrequency': frequency,\n                'queryPeriod': lookup_period,\n                'triggerOperator': trigger_operator,\n                'triggerThreshold': trigger_threshold,\n                'suppressionEnabled': enable_suppression,\n                'suppressionDuration': suppression_duration,\n                'description': description,\n                'tactics': tactics\n            }\n        }\n\n        response = self.session.put(\n            self._get_full_url('alert_rules', alert_rule_id=uuid.uuid4()),\n            params=params,\n            json=json_payload\n        )\n        self.validate_response(response)\n\n        return self.sentinel_parser.build_siemplify_alert_rule_obj(response.json())\n\n    def update_alert_rule(self, alert_rule_id, enable_alert_rule=None, name=None, severity=None, query=None,\n                          frequency=None, lookup_period=None, trigger_operator=None, trigger_threshold=None,\n                          enable_suppression=None, suppression_duration=None, description=None, tactics=None):\n        # type: (str, bool, str, str, str, str, str, str, int, bool, str, str, list) -> object\n        \"\"\"\n        Update existing alert rule\n        @param alert_rule_id: ID of the Alert Rule to update\n        @param enable_alert_rule: Enables or Disables alert rule\n        @param name: Alert Rule name\n        @param severity: Alert Rule severity\n        @param query: Alert rule query\n        @param frequency: How frequently to run the query\n        @param lookup_period: Time of the last lookup data\n        @param trigger_operator: Alert Rule trigger operator\n        @param trigger_threshold: Alert Rule trigger threshold\n        @param enable_suppression: Whether you want to stop running query after alert is generated\n        @param suppression_duration: How long you want to stop running query after alert is generated\n        @param description: Alert Rule description\n        @param tactics: Alert Rule tactics\n        @return: Updated Alert Rule\n        \"\"\"\n        alert_rule = self.get_alert_rule(alert_rule_id)\n        json_payload = self.modify_alert_rule_json_payload(alert_rule, enable_alert_rule, name, severity, query,\n                                                           frequency, lookup_period, trigger_operator, trigger_threshold,\n                                                           enable_suppression, suppression_duration, description,\n                                                           tactics)\n        params = {\n            'api-version': self._get_endpoint_version('alert_rules')\n        }\n\n        response = self.session.put(\n            self._get_full_url('alert_rules', alert_rule_id=alert_rule_id),\n            params=params,\n            json=json_payload\n        )\n        self.validate_response(response)\n\n        return self.sentinel_parser.build_siemplify_alert_rule_obj(response.json())\n\n    def modify_alert_rule_json_payload(self, alert_rule, enable_alert_rule=None, name=None,\n                                       severity=None, query=None, frequency=None, lookup_period=None,\n                                       trigger_operator=None, trigger_threshold=None, enable_suppression=None,\n                                       suppression_duration=None, description=None, tactics=None):\n        \"\"\"\n        Get updating modified data\n        @param alert_rule: AlertRule object\n        @param enable_alert_rule: Enables or Disables alert rule\n        @param name: Alert Rule name\n        @param severity: Alert Rule severity\n        @param query: Alert rule query\n        @param frequency: How frequently to run the query\n        @param lookup_period: Time of the last lookup data\n        @param trigger_operator: Alert Rule trigger operator\n        @param trigger_threshold: Alert Rule trigger threshold\n        @param enable_suppression: Whether you want to stop running query after alert is generated\n        @param suppression_duration: How long you want to stop running query after alert is generated\n        @param description: Alert Rule description\n        @param tactics: Alert Rule tactics\n        @return: Updated Alert Rule\n        \"\"\"\n        alert_rule_data = alert_rule.get_original_data()\n\n        tactics = alert_rule.properties.tactics + [tactic for tactic in tactics if tactic not in alert_rule.properties.tactics]\n        properties = {\n            'enabled': enable_alert_rule,\n            'displayName': name,\n            'severity': severity,\n            'query': query,\n            'queryFrequency': frequency,\n            'queryPeriod': lookup_period,\n            'triggerOperator': trigger_operator,\n            'triggerThreshold': trigger_threshold,\n            'suppressionEnabled': enable_suppression,\n            'suppressionDuration': suppression_duration,\n            'description':  description,\n            'tactics': list(set(tactics))\n        }\n        properties = {key: value for key, value in properties.items() if value is not None}\n        # READ-ONLY field\n        del alert_rule_data['properties']['lastModifiedUtc']\n        alert_rule_data['properties'].update(properties)\n\n        return alert_rule_data\n\n    def delete_alert_rule(self, alert_rule_id):\n        # type: (str) -> None\n        \"\"\"\n        Delete Alert Rule\n        @param alert_rule_id: ID of the Alert Rule to delete\n        \"\"\"\n        # To check if alert exists\n        self.get_alert_rule(alert_rule_id=alert_rule_id)\n        params = {\n            'api-version': self._get_endpoint_version('alert_rules')\n        }\n\n        response = self.session.delete(self._get_full_url('alert_rules', alert_rule_id=alert_rule_id), params=params)\n        self.validate_response(response)\n\n    def get_custom_hunting_rules(self, names=None, tactics=None, limit=None):\n        # type: (list, list, int) -> [object]\n        \"\"\"\n        Get all Custom Hunting Rules including filters\n        @param names: Custom Hunting Rules names\n        @param tactics: Custom Hunting Rules tactics\n        @param limit: Limited items to return\n        @return: Filtered Custom Hunting Rules\n        \"\"\"\n        params = {\n            'api-version': self._get_endpoint_version('custom_hunting_rules_listing'),\n            QueryFilterKeyEnum.LIMIT.value: limit\n        }\n        response = self.session.get(\n            self._get_full_url('custom_hunting_rules_listing'),\n            params=params\n        )\n        hunting_rules = self.sentinel_parser.build_results(response.json(), 'build_siemplify_custom_hunting_rule_obj')\n\n        return self._filter_custom_hunting_rules(hunting_rules, names, tactics)[:limit]\n\n    def get_custom_hunting_rule(self, custom_hunting_rule_id):\n        # type: (str) -> object\n        \"\"\"\n        Get specific Custom Hunting Rule\n        @param custom_hunting_rule_id: Custom Hunting Rule ID\n        @return: Custom Hunting Rule\n        \"\"\"\n        hunting_rule = self._get_custom_hunting_rule(custom_hunting_rule_id)\n\n        return self.sentinel_parser.build_siemplify_custom_hunting_rule_obj(hunting_rule)\n\n    def _get_custom_hunting_rule(self, custom_hunting_rule_id):\n        params = {\n            'api-version': self._get_endpoint_version('custom_hunting_rules'),\n        }\n        response = self.session.get(\n            self._get_full_url('custom_hunting_rules', custom_hunting_rule_id=custom_hunting_rule_id),\n            params=params\n        )\n        self.validate_response(response)\n\n        return response.json()\n\n    def create_custom_hunting_rule(self, query, display_name, description=None, tactics=None):\n        # type: (str, str, str, list) -> object\n        \"\"\"\n        Create new Custom Hunting Rule\n        @param query: Custom Hunting Rule query\n        @param display_name: Custom Hunting Ruled display name\n        @param description: Custom Hunting Rule description\n        @param tactics: Custom Hunting Rule tactics\n        @return: New Custom Hunting Rule\n        \"\"\"\n        params = {\n            'api-version': self._get_endpoint_version('custom_hunting_rules'),\n        }\n\n        tags = TagCollection()\n\n        if tactics:\n            tags.set_from_list('tactics', tactics)\n        if description:\n            tags.set('description', description)\n\n        custom_hunting_rule = CustomHuntingRuleRequest()\n        custom_hunting_rule.name = custom_hunting_rule.id = uuid.uuid4()\n        custom_hunting_rule.properties.query = query\n        custom_hunting_rule.properties.display_name = display_name\n        custom_hunting_rule.properties.tags = tags\n\n        response = self.session.put(\n            self._get_full_url('custom_hunting_rules', custom_hunting_rule_id=custom_hunting_rule.id),\n            params=params,\n            json=custom_hunting_rule.to_create_json()\n        )\n        self.validate_response(response)\n\n        return self.sentinel_parser.build_siemplify_custom_hunting_rule_obj(response.json())\n\n    def update_custom_hunting_rule(self, custom_hunting_rule_id, display_name=None, query=None, description=None,\n                                   tactics=None):\n        # type: (str, str, str, str, list) -> object\n        \"\"\"\n        Update existing Custom Hunting Rule\n        @param custom_hunting_rule_id: Custom Hunting Rule ID\n        @param display_name: Custom Hunting Rule display name\n        @param query: Custom Hunting Rule query\n        @param description: Custom Hunting Rule description\n        @param tactics: Custom Hunting Rule tactics\n        @return: Updated Custom Hunting Rule\n        \"\"\"\n        hunting_rule = self._get_custom_hunting_rule(custom_hunting_rule_id)\n        custom_hunting_rule = self.sentinel_parser.build_siemplify_custom_hunting_rule_req_obj(hunting_rule)\n\n        display_name_to_update = display_name or custom_hunting_rule.properties.display_name\n        custom_hunting_rule.properties.display_name = display_name_to_update\n\n        query_to_update = query or custom_hunting_rule.properties.query\n        custom_hunting_rule.properties.query = query_to_update\n\n        if description:\n            custom_hunting_rule.properties.tags.remove_all('description')\n            custom_hunting_rule.properties.tags.set('description', description)\n\n        if tactics:\n            custom_hunting_rule.properties.tags.set_from_list_unique_values(name='tactics', values=tactics,\n                                                                            unique_tag_name='tactics')\n        response = self.session.put(\n            self._get_full_url('custom_hunting_rules', custom_hunting_rule_id=custom_hunting_rule_id),\n            params={'api-version': self._get_endpoint_version('custom_hunting_rules')},\n            json=custom_hunting_rule.to_update_json()\n        )\n        self.validate_response(response)\n\n        return self.sentinel_parser.build_siemplify_custom_hunting_rule_obj(response.json())\n\n    def delete_custom_hunting_rule(self, custom_hunting_rule_id):\n        # type: (str) -> None\n        \"\"\"\n        Delete Custom Hunting Rule\n        @param custom_hunting_rule_id: Custom Hunting Rule ID\n        \"\"\"\n        # To check if custom hunting rule exists\n        self.get_custom_hunting_rule(custom_hunting_rule_id=custom_hunting_rule_id)\n\n        params = {\n            'api-version': self._get_endpoint_version('custom_hunting_rules'),\n        }\n\n        response = self.session.delete(\n            self._get_full_url('custom_hunting_rules', custom_hunting_rule_id=custom_hunting_rule_id),\n            params=params\n        )\n        self.validate_response(response)\n\n    def run_custom_hunting_rule(self, custom_hunting_rule_id, timeout=None):\n        # type: (str, int) -> object\n        \"\"\"\n        Run query of Custom Hunting Rule\n        @param custom_hunting_rule_id: Custom Hunting Rule ID\n        @param timeout: timeout value for the Azure Sentinel hunting rule API call.\n        @return: Query Result\n        \"\"\"\n        custom_hunting_rule = self.get_custom_hunting_rule(custom_hunting_rule_id)\n\n        return self.run_kql_query(custom_hunting_rule.properties.query, timeout=timeout)\n\n    def run_kql_query(self, query, timespan=None, timeout=None, duration=None, limit=None):\n        # type: (str, str, int, str, int) -> object or list\n        \"\"\"\n        Run query\n        @param query: Query\n        @param timespan: Time span to look for\n        @param timeout: timeout value for the Azure Sentinel hunting rule API call\n        @param duration: Duration (servertimeout)\n        @param limit: How much results should be fetched\n        @return: Query Result\n        \"\"\"\n        params = {\n            'api-version': self._get_endpoint_version('kql_query'),\n            'timespan': timespan,\n        }\n\n        json_request = {\n            'query': f'{query} | limit {limit}' if limit else query,\n            'servertimeout': duration\n        }\n\n        json_request = {k: v for k, v in json_request.items() if v}\n\n        if timeout:\n            self._add_session_header('Prefer', f'wait={timeout}')\n\n        response = self.session.post(self._get_full_url('kql_query'), params=params, json=json_request)\n\n        self._remove_session_header('Prefer')\n\n        self.validate_response(response)\n\n        query_result = self.sentinel_parser.build_results(\n            raw_json=response.json(),\n            method='build_siemplify_primary_result_obj',\n            data_key='tables'\n        )\n\n        return query_result and query_result[0]\n\n    def get_incidents_by_filter(self, creation_time=None, time_frame=None, statuses=None, severities=None, limit=None,\n                                asc=False):\n        # type: (datetime, int, list, list, int, bool) -> [object]\n        \"\"\"\n        Get all Incidents including filters\n        @param creation_time: Get incidents with creationTimeUtc greater than passed datetime\n        @param time_frame: Time frame for which to show the statistics\n        @param statuses: Statuses of the incidents to look for\n        @param severities: Severities of the incidents to look for\n        @param limit: How much results should be fetched\n        @param asc: Whether to bring incidents in ascending or descending order\n        @return: Incidents\n        \"\"\"\n        params = {\n            'api-version': self._get_endpoint_version('incidents'),\n        }\n\n        query = str(QueryBuilder([\n            Condition(field='properties/createdTimeUtc', operator=OperatorEnum.GE.value,\n                      value_formatter=('format_time', TIME_FORMAT), value=creation_time),\n            Condition(field='properties/createdTimeUtc', operator=OperatorEnum.GE.value,\n                      value_formatter=('set_hours_back', TIME_FORMAT), value=time_frame),\n            Condition(field='properties/status', operator=OperatorEnum.EQ.value, value=statuses,\n                      value_with_quotes=True, join_values_with=QueryOperatorEnum.OR.value),\n            Condition(field='properties/severity', operator=OperatorEnum.EQ.value, value=severities,\n                      value_with_quotes=True, join_values_with=QueryOperatorEnum.OR.value)\n        ]))\n        if query:\n            params[QueryFilterKeyEnum.FILTER.value] = query\n\n        if asc:\n            params[QueryFilterKeyEnum.ORDER_BY.value] = 'properties/createdTimeUtc asc'\n\n        if limit:\n            params[QueryFilterKeyEnum.LIMIT.value] = limit\n\n        response = self.session.get(self._get_full_url('incidents'), params=params)\n        self.validate_response(response)\n\n        return self.sentinel_parser.build_results(response.json(), 'build_siemplify_incident_obj', limit=limit)\n\n    def get_incidents(self, creation_time=None, time_frame=None, statuses=None, severities=None, limit=None, extend_alerts=False,\n                      asc=True):\n        # type: (datetime, int, list, list, int, bool, bool) -> [object]\n        \"\"\"\n        Get all Incidents including filters\n        @param creation_time: Get incidents with creationTimeUtc greater than passed datetime\n        @param time_frame: Time frame for which to show the statistics\n        @param statuses: Statuses of the incidents to look for\n        @param severities: Severities of the incidents to look for\n        @param limit: How much results should be fetched\n        @param extend_alerts: Convert\n        @param asc: Whether to bring incidents in ascending or descending order\n        @return: Incidents\n        \"\"\"\n        api_parameters = self._build_api_parameters(\n            api_version=self._get_endpoint_version('incident_cases'),\n            creation_time=creation_time,\n            time_frame=time_frame,\n            statuses=statuses,\n            severities=severities,\n            asc=asc,\n            limit=limit\n        )\n\n        response = self.session.get(self._get_full_url('incident_cases'), params=api_parameters)\n        self.validate_response(response)\n\n        incidents_data = response.json().get('value')\n\n        incidents = []\n        for incident_data in incidents_data:\n            incident = self.sentinel_parser.build_siemplify_incident_obj(incident_data)\n\n            if extend_alerts:\n                if not incident.properties.related_alert_ids:\n                    self.logger.info(f'Incorrect formatted incident \"{incident.id}\". Skipping...')\n                    continue\n\n                incident.properties.alerts = self._get_alerts_by_id(*incident.properties.related_alert_ids,\n                                                                    incident_number=incident.properties.case_number)\n                for alert in incident.properties.alerts:\n                    alert['Events'] = self._get_alert_events(alert) \\\n                        if alert.get('ProviderName') == 'ASI Scheduled Alerts' else []\n\n            incidents.append(incident)\n\n        return incidents\n\n    def get_incidents_with_new_endpoint(self, creation_time=None, time_frame=None, statuses=None,\n                                        severities=None, limit=None, asc=True, use_same_approach=False,\n                                        existing_ids=None, next_page_link=None, connector_starting_time=None,\n                                        python_process_timeout=None, scheduled_alerts_events_limit=None,\n                                        incidents_alerts_limit_to_ingest=None, backlog_ids=None):\n        \"\"\"\n        Get all Incidents including filters\n        :param creation_time: {datetime} Get incidents with creationTimeUtc greater than passed datetime\n        :param time_frame: {int} Time frame for which to show the statistics\n        :param statuses: {list} Statuses of the incidents to look for\n        :param severities: {list} Severities of the incidents to look for\n        :param limit: {int} How much results should be fetched\n        :param asc: {bool} Whether to bring incidents in ascending or descending order\n        :param use_same_approach: {bool} Whether to use the same approach with event creation for all alert types\n        :param existing_ids: {list} The incident ids that were already processed\n        :param next_page_link: {str} The next page link, to use pagination across connector execution\n        :param connector_starting_time: {int} Connector start time\n        :param python_process_timeout: {int} The python process timeout\n        :param scheduled_alerts_events_limit: {int} Limit for scheduled alerts events\n        :param incidents_alerts_limit_to_ingest: {int} Limit for alerts per single Azure Sentinel incident\n        :param backlog_ids: {dict} Backlog ids dict\n        :return: {list} List of Incident objects\n        \"\"\"\n        api_parameters = self._build_api_parameters(\n            api_version=self._get_endpoint_version('incidents'),\n            creation_time=creation_time,\n            time_frame=time_frame,\n            statuses=statuses,\n            severities=severities,\n            asc=asc,\n            limit=limit\n        )\n\n        request_url, api_parameters = (next_page_link, None) if next_page_link else \\\n            (self._get_full_url('incidents'), api_parameters)\n\n        response = self.session.get(request_url, params=api_parameters)\n\n        self.validate_response(response)\n\n        json_response = response.json()\n        next_page_link = self.sentinel_parser.get_next_page_link(json_response)\n\n        incidents_data = json_response.get('value')\n\n        incidents = self.adjust_incidents_alert(incidents_data, existing_ids, use_same_approach,\n                                                connector_starting_time=connector_starting_time,\n                                                python_process_timeout=python_process_timeout,\n                                                scheduled_alerts_events_limit=scheduled_alerts_events_limit,\n                                                incidents_alerts_limit_to_ingest=incidents_alerts_limit_to_ingest,\n                                                backlog_ids=backlog_ids)\n\n        return incidents, next_page_link\n\n    def adjust_incidents_alert(self, incidents_data, existing_ids, use_same_approach,\n                               connector_starting_time=None, python_process_timeout=None,\n                               scheduled_alerts_events_limit=None, incidents_alerts_limit_to_ingest=None,\n                               backlog_ids=None):\n        \"\"\"\n        Update incident data\n        :param incidents_data: {list} Incidents json\n        :param existing_ids: {list} The incident ids that were already processed\n        :param use_same_approach: {bool} Whether to use the same approach with event creation for all alert types\n        :param connector_starting_time: {int} Connector start time\n        :param python_process_timeout: {int} The python process timeout\n        :param scheduled_alerts_events_limit: {int} Limit for scheduled alerts events\n        :param incidents_alerts_limit_to_ingest: {int} Limit for alerts per single Azure Sentinel incident\n        :param backlog_ids: {dict} Backlog ids dict\n        return {list} List of Incident objets\n        \"\"\"\n        incidents = []\n        fetched_incidents = []\n        MicrosoftAzureSentinelCommon.raise_if_timeout(connector_starting_time, python_process_timeout)\n        for incident_data in incidents_data:\n            incident = self.sentinel_parser.build_siemplify_incident_obj(incident_data)\n            fetched_incidents.append(incident)\n\n        MicrosoftAzureSentinelCommon.raise_if_timeout(connector_starting_time, python_process_timeout)\n\n        filtered_incidents = self.sentinel_common.filter_old_ids(fetched_incidents, existing_ids)\n\n        for incident in filtered_incidents:\n            MicrosoftAzureSentinelCommon.raise_if_timeout(connector_starting_time, python_process_timeout)\n            incident.properties.alerts = self.get_incident_alerts_by_id(incident.name)\n            incident_alerts = []\n\n            for alert in incident.properties.alerts:\n                MicrosoftAzureSentinelCommon.raise_if_timeout(connector_starting_time, python_process_timeout)\n                if len(incident_alerts) >= incidents_alerts_limit_to_ingest:\n                    self.logger.info(f\"Incident's {incident.name} Alerts Limit to Ingest was reached,\"\n                                     f\" no more alerts will be processed.\")\n                    break\n\n                if not use_same_approach and alert.properties.product_component_name in ALERT_TYPES_WITH_EVENTS:\n                    MicrosoftAzureSentinelCommon.raise_if_timeout(connector_starting_time, python_process_timeout)\n                    alerts_with_old_api = self._get_alerts_by_id(alert.properties.system_alert_id,\n                                                                 incident_number=incident.properties.incident_number)\n\n                    if alerts_with_old_api:\n                        incident_alerts.extend(alerts_with_old_api)\n\n                        for scheduled_alert in alerts_with_old_api:\n                            MicrosoftAzureSentinelCommon.raise_if_timeout(connector_starting_time,\n                                                                          python_process_timeout)\n                            try:\n                                scheduled_alert['Events'] = self._get_alert_events(scheduled_alert,\n                                                                                   scheduled_alerts_events_limit)\n                            except Exception:\n                                scheduled_alert['Events'] = []\n                                self.logger.error(\n                                    f\"Failed to process Azure Sentinel Scheduled Alert with id {incident.name} and \"\n                                    f\"incident number {incident.properties.incident_number}! Query field of the \"\n                                    f\"affected alert: \\\"{json.loads(scheduled_alert.get('ExtendedProperties')).get('Query')}\\\"\")\n                        continue\n                    else:\n                        self.logger.error(f\"Failed to fetch incident {incident.properties.incident_number} scheduled \"\n                                          f\"or NRT alerts. Will send it to backlog.\")\n                else:\n                    MicrosoftAzureSentinelCommon.raise_if_timeout(connector_starting_time, python_process_timeout)\n\n                    if len(incident.properties.alerts) == 1:\n                        alert.entities = self.get_incident_entities(alert.properties.system_alert_id,\n                                                                    incident.properties.incident_number,\n                                                                    incident.name,\n                                                                    backlog_ids)\n                    else:\n                        alert.entities = self.get_alert_entities(alert.properties.system_alert_id,\n                                                                 incident.properties.incident_number,\n                                                                 incident.name,\n                                                                 backlog_ids)\n                    incident_alerts.append(alert)\n\n            incident.properties.alerts = incident_alerts\n            incidents.append(incident)\n\n        return sorted(incidents, key=lambda _alert: _alert.properties.created_time_unix)\n\n    def get_incident_alerts_by_id(self, incident_id):\n        \"\"\"\n        Get Azure Sentinel alerts related to  specific incident.\n        :param incident_id: {str} ID of the incident\n        :return: {list} List of Alert objects\n        \"\"\"\n        url = '{}{}'.format(self.base_url, API_ENDPOINTS['GET_INCIDENT_ALERTS']['URL'].format(incident_name=incident_id))\n        api_parameters = self._build_api_parameters(api_version=API_ENDPOINTS['GET_INCIDENT_ALERTS']['VERSION'])\n\n        response = self.session.post(url, params=api_parameters)\n        self.validate_response(response)\n        alerts_data = response.json().get('value', [])\n        return [self.sentinel_parser.build_siemplify_incident_alert_obj(alert_data) for alert_data in alerts_data] \\\n            if alerts_data else []\n\n    def get_alert_entities(self, alert_id, incident_number, incident_id, backlog_ids):\n        \"\"\"\n        Get Azure Sentinel  entities related to  specific alert from the incident.\n        :param alert_id: {str} Id of the alert\n        :param incident_number: {int} The number of the incident\n        :param incident_id: {str} ID of the incident\n        :param backlog_ids: {dict} Backlog ids dict\n        :return: {list} List of Entity objects\n        \"\"\"\n        url = '{}{}'.format(self.base_url, API_ENDPOINTS['GET_ALERT_ENTITIES']['URL'].format(alert_id=alert_id))\n        params = {\n            'api-version': API_ENDPOINTS['GET_ALERT_ENTITIES']['VERSION']\n        }\n        payload = {\n            'expansionId': API_ENDPOINTS['GET_ALERT_ENTITIES']['DEFAULT_EXPANSION_ID']\n        }\n\n        response = self.session.post(url, json=payload, params=params)\n\n        try:\n            self.validate_response(response)\n        except Exception as e:\n            if isinstance(e, MicrosoftAzureSentinelTimeoutError):\n                raise \n            if incident_number not in backlog_ids:\n                self.logger.error(\"Failed to fetch alert {} entities. Will send it to backlog. Incident {}\".\n                                  format(alert_id, incident_id))\n            return None\n\n        response_data = response.json().get('value', {})\n        edges_data = response_data.get('edges', [])\n        return [self.sentinel_parser.build_siemplify_alert_entity_obj(\n            entity_data, next((edge.get('additionalData', {}) for edge in edges_data if edge.get('targetEntityId')\n                               == entity_data.get('id')), None)) for entity_data in response_data.get('entities', [])]\n\n    def get_incident_by_number(self, incident_number, use_same_approach=False,\n                               scheduled_alerts_events_limit=None, backlog_ids=None):\n        \"\"\"\n        Get incident by its number\n        :param incident_number: {int} The number of the incident\n        :param use_same_approach: {bool} Whether to use the same approach with event creation for all alert types\n        :param scheduled_alerts_events_limit: {int} Limit for scheduled alerts events\n        :param backlog_ids: (dict} Backlog IDs dict\n        :return: Incident\n        \"\"\"\n        params = {\n            'api-version': self._get_endpoint_version('incidents'),\n            QueryFilterKeyEnum.FILTER.value: 'properties/incidentNumber eq {}'.format(incident_number)\n        }\n        response = self.session.get(self._get_full_url('incidents'), params=params)\n        self.validate_response(response)\n        incident_data = response.json().get('value')\n\n        if not incident_data:\n            raise MicrosoftAzureSentinelManagerError('Incident with number {} was not found'.format(incident_number))\n\n        incident = self.sentinel_parser.build_siemplify_incident_obj(incident_data[0])\n        incident.properties.alerts = self.get_incident_alerts_by_id(incident.name)\n        incident_alerts_with_old_api = []\n\n        for alert in incident.properties.alerts:\n            if not use_same_approach and alert.properties.product_component_name in ALERT_TYPES_WITH_EVENTS:\n                alerts_with_old_api = self._get_alerts_by_id(alert.properties.system_alert_id,\n                                                             incident_number=incident_number)\n                if alerts_with_old_api:\n                    incident_alerts_with_old_api.extend(alerts_with_old_api)\n                    incident.properties.alerts = incident_alerts_with_old_api\n\n                    for scheduled_alert in alerts_with_old_api:\n                        scheduled_alert['Events'] = self._get_alert_events(scheduled_alert, scheduled_alerts_events_limit)\n\n                    continue\n            else:\n                if len(incident.properties.alerts) == 1:\n                    alert.entities = self.get_incident_entities(alert.properties.system_alert_id, incident_number,\n                                                                incident.name, backlog_ids)\n                else:\n                    alert.entities = self.get_alert_entities(alert.properties.system_alert_id, incident_number,\n                                                             incident.name, backlog_ids)\n        return incident\n\n    def get_incident_statistics(self, time_frame=None):\n        # type: (int) -> object\n        \"\"\"\n        Get Incident statistic\n        @param time_frame: Time frame for which to show the statistics\n        @return: IncidentStatistic instance\n        \"\"\"\n        params = {'api-version': self._get_endpoint_version('incident_aggregation')}\n\n        end_time = datetime.utcnow()\n        start_time = end_time - timedelta(hours=time_frame)\n\n        params[QueryFilterKeyEnum.START_TIME.value] = start_time.strftime(TIME_FORMAT)\n\n        params[QueryFilterKeyEnum.END_TIME.value] = end_time.strftime(TIME_FORMAT)\n\n        response = self.session.get(self._get_full_url('incident_aggregation'), params=params)\n        self.validate_response(response)\n\n        return self.sentinel_parser.build_siemplify_incident_statistic_obj(response.json())\n\n    def get_incident_by_incident_number(self, incident_number):\n        return self._get_incident_by_incident_number(incident_number=incident_number)\n\n    def add_comment_to_incident(self, incident_name, comment):\n        \"\"\"\n        Add Comment to the incident\n        @param incident_name: {str} Incident number\n        @param comment: {str} comment to add to Incident\n        @return: {Incident} updated incident details\n        \"\"\"\n        params = {'api-version': self._get_endpoint_version('incident_comment')}\n        json_payload = {\n            'properties': {\n                'message': comment\n            }\n        }\n\n        response = self.session.put(\n            self._get_full_url('incident_comment', incident_number=incident_name, incident_comment_id=uuid.uuid4()),\n            params=params,\n            json=json_payload\n        )\n        self.validate_response(response)\n\n        return self.sentinel_parser.build_siemplify_incident_obj(raw_json=response.json())\n\n    def _get_incident_by_incident_number(self, incident_number):\n        \"\"\"\n        Update existing Incident\n        @param incident_number: {str} Incident number\n        @return: {Incident} instance\n        \"\"\"\n        filter_query = QueryBuilder([\n            Condition(field='properties/incidentNumber', operator='eq', value=incident_number)\n        ])\n        params = {\n            'api-version': self._get_endpoint_version('incidents'),\n            QueryFilterKeyEnum.FILTER.value: str(filter_query)\n        }\n\n        response = self.session.get(self._get_full_url('incidents'), params=params)\n        self.validate_response(response)\n\n        incident = self.sentinel_parser.build_results(response.json(), 'build_siemplify_incident_obj')\n\n        if incident:\n            return incident[0]\n\n    def update_incident_labels(self, incident_number, labels=None):\n        \"\"\"\n        Update existing Incident\n        @param incident_number: {str} Incident by number to update\n        @param labels: {list} Incident labels\n        @return: Updated Incident\n        \"\"\"\n        incident = self._get_incident_by_incident_number(incident_number)\n\n        url = self._get_full_url('incident', incident_name=incident.name)\n        params = {\n            'api-version': self._get_endpoint_version('incident'),\n        }\n        json_payload, updated_labels, not_updated_labels = incident.update_labels(labels)\n\n        response = self.session.put(url, params=params, json=json_payload)\n        self.validate_response(response)\n\n        return self.sentinel_parser.build_siemplify_incident_obj(response.json()), updated_labels, not_updated_labels\n\n    def update_incident(self, incident_number, title=None, status=None, severity=None, description=None,\n                        assigned_to=None, close_reason=None, closing_comment=None):\n        # type: (int, str, str, str, str, str, str, list) -> object\n        \"\"\"\n        Update existing Incident\n        @param incident_number: Number of Incident to be updated\n        @param title: Incident title\n        @param status: Incident status\n        @param severity: Incident severity\n        @param description: Incident description\n        @param assigned_to: Incident assignee\n        @param close_reason: Incident close reason\n        @param closing_comment: Closing comment\n        @return: Updated Incident\n        \"\"\"\n        incident = self._get_incident_by_incident_number(incident_number)\n        params = {\n            'api-version': self._get_endpoint_version('incident')\n        }\n        json_payload = self.update_incident_payload(incident.get_original_data(), title, status, severity, description,\n                                                    assigned_to, close_reason, closing_comment)\n        response = self.session.put(\n            self._get_full_url('incident', incident_name=incident.name),\n            params=params,\n            json=json_payload\n        )\n        self.validate_response(response)\n\n        return self.sentinel_parser.build_siemplify_incident_obj(response.json())\n\n    def update_incident_payload(self, data, title=None, status=None, severity=None, description=None, assigned_to=None,\n                                close_reason=None, closing_comment=None):\n        \"\"\"\n        Update existing Incident\n        @param data: Incident data\n        @param title: Incident title\n        @param status: Incident status\n        @param severity: Incident severity\n        @param description: Incident description\n        @param assigned_to: Incident assignee\n        @param close_reason: Incident close reason\n        @param closing_comment: Closing comment\n        @return: {dict} Updated Incident data\n        \"\"\"\n        if title:\n            data['properties']['title'] = title\n\n        if status and status not in ADDITIONAL_DEFAULT_FOR_VALIDATION:\n            data['properties']['status'] = status\n            # In case of when changing from close status to other\n            if status != CLOSED:\n                data['properties']['classification'] = ''\n                data['properties']['classificationReason'] = ''\n                data['properties']['classificationComment'] = ''\n\n        if severity and severity not in ADDITIONAL_DEFAULT_FOR_VALIDATION:\n            data['properties']['severity'] = severity\n\n        if description:\n            data['properties']['description'] = description\n\n        if assigned_to:\n            data['properties']['owner']['assignedTo'] = assigned_to\n\n        if close_reason and close_reason not in ADDITIONAL_DEFAULT_FOR_VALIDATION:\n            classification, classification_reason = self.modify_classification(close_reason)\n            data['properties']['classification'] = classification\n            data['properties']['classificationReason'] = classification_reason\n            data['properties']['classificationComment'] = closing_comment or ''\n\n        return data\n\n    def modify_classification(self, reason):\n        \"\"\"\n        Update incident reason\n        @param reason: {str} Incident closing reason\n        :return classification: {str} updated closing reason\n        \"\"\"\n        classifications_list = reason.split(CLOSE_REASON_DELIMITER)\n        reason = classifications_list[-1].replace(' ', '').capitalize() if len(classifications_list) > 1 else ''\n\n        return classifications_list[0].replace(' ', ''), reason\n\n    def _get_alerts_by_id(self, *ids, incident_number=None):\n        # type: (str) -> list\n        \"\"\"\n        Get all alerts by provided ids\n        @param ids: IDs of the alerts\n        @param incident_number: Number of the incident\n        @return: Alerts\n        \"\"\"\n        query = 'SecurityAlert | summarize arg_max(TimeGenerated, *) by SystemAlertId | where SystemAlertId in({})' \\\n            .format(', '.join([f'\\\"{x}\\\"' for x in ids]))\n\n        try:\n            return self.run_kql_query(query=query).to_json()\n        except MicrosoftAzureSentinelBadRequestError:\n            if incident_number:\n                self.logger.error(\n                    f\"Incident {incident_number} was skipped because it didn't had SystemAlertID value present on the \"\n                    'time of ingestion')\n                return []\n            raise\n\n    def _get_alert_events(self, alert, limit=None):\n        # type: (dict) -> list\n        \"\"\"\n        Get event list for alert\n        @param alert: Alert\n        @param limit {int}: Limit for results\n        @return: List of Events\n        \"\"\"\n        extended_properties = json.loads(alert.get('ExtendedProperties'))\n        start_time = convert_string_to_datetime(extended_properties.get('Query Start Time UTC'), \"UTC\")\\\n            .strftime(TIME_FORMAT)\n        end_time = convert_string_to_datetime(extended_properties.get('Query End Time UTC'), \"UTC\")\\\n            .strftime(TIME_FORMAT)\n\n        query = extended_properties.get('Query')\n        timespan = '{}/{}'.format(start_time, end_time)\n\n        return self.run_kql_query(query=query, timespan=timespan, limit=limit).to_json()\n\n    @staticmethod\n    def _build_api_parameters(api_version=DEFAULT_API_VERSION, statuses=None, time_frame=None, severities=None,\n                              case_number=None, start_time=None, end_time=None, limit=None, asc=False, timespan=None,\n                              creation_time=None):\n        # type: (str, list, int, list, int, str, str, int, bool, str, datetime) -> object\n        \"\"\"\n        Method to build api parameters in URL\n        @param api_version: API VERSION\n        @param statuses: Statuses\n        @param time_frame: Time Frame\n        @param severities: Severities\n        @param case_number: Case Number\n        @param start_time: Start Time\n        @param end_time: End Time\n        @param limit: Limit\n        @param asc: Asc\n        @param timespan: Time Span\n        @param creation_time: Search for incidents with createdTimeUtc greater than given datetime\n        @return: API parameters\n        \"\"\"\n        params = {'api-version': api_version}\n        filter_params = []\n\n        if case_number:\n            filter_params.append('properties/caseNumber eq {}'.format(case_number))\n\n        if creation_time:\n            filter_params.append('properties/createdTimeUtc ge {}'.format(creation_time.strftime(TIME_FORMAT)))\n\n        elif time_frame:\n            time = datetime.utcnow() - timedelta(hours=time_frame)\n            filter_params.append('properties/createdTimeUtc ge {}'.format(time.strftime(TIME_FORMAT)))\n\n        if statuses:\n            statuses_filter_group = \" or \".join([\"properties/status eq '{}'\".format(x) for x in statuses])\n            filter_params.append(\"({})\".format(statuses_filter_group))\n\n        if severities:\n            severities_filter_group = \" or \".join([\"properties/severity eq '{}'\".format(x) for x in severities])\n            filter_params.append(\"({})\".format(severities_filter_group))\n\n        # Apply filtering in oData format\n\n        if filter_params:\n            params['$filter'] = \" and \".join(filter_params)\n\n        if asc:\n            params['$orderBy'] = 'properties/createdTimeUtc asc'\n\n        if limit:\n            params['$top'] = limit\n\n        if start_time:\n            params['startTime'] = start_time\n\n        if end_time:\n            params['endTime'] = end_time\n\n        if timespan:\n            params['timespan'] = timespan\n\n        return params\n\n    @staticmethod\n    def _filter_alert_rules(alert_rules, severities=None, types=None, tactics=None, only_enabled_rules=False, limit=None):\n        # type: (list, list, list, list, bool, int) -> [object]\n        \"\"\"\n        Client-Side alert rules filtering\n        @param alert_rules: Alert Rules before filtration\n        @param severities: Severities to filter\n        @param types: Types to filter\n        @param tactics: Tactics to filter\n        @param only_enabled_rules: Filter only enabled Alert Rules\n        @param limit: Alert Rules to return\n        @return: Filtered Alert Rules\n        \"\"\"\n        filtered_alert_rules = []\n\n        for alert_rule in alert_rules:\n            conditions = []\n\n            if severities:\n                conditions += [\n                    alert_rule.properties and\n                    alert_rule.properties.severity and\n                    alert_rule.properties.severity in severities\n                ]\n\n            if types:\n                conditions += [\n                    alert_rule.kind and\n                    alert_rule.kind in types\n                ]\n\n            if tactics:\n                conditions += [\n                    alert_rule.properties and\n                    alert_rule.properties.tactics and\n                    any([tactic in tactics for tactic in alert_rule.properties.tactics])\n                ]\n\n            if only_enabled_rules:\n                conditions += [\n                    alert_rule.properties and\n                    alert_rule.properties.enabled\n                ]\n\n            if all(conditions):\n                filtered_alert_rules.append(alert_rule)\n\n        return filtered_alert_rules[:limit]\n\n    @staticmethod\n    def _filter_custom_hunting_rules(custom_hunting_rules, names=None, tactics=None):\n        # type: (list, list, list) -> [object]\n        \"\"\"\n        Client-Side Custom Hunting Rules filtering\n        @param custom_hunting_rules: Custom Hunting Rules before filtration\n        @param names: Names to filter\n        @param tactics: Tactics to filter\n        @return: Filtered Custom Hunting Rule\n        \"\"\"\n        filtered_custom_hunting_rules = []\n\n        for custom_hunting_rule in custom_hunting_rules:\n            conditions = []\n\n            if names:\n                conditions += [\n                    custom_hunting_rule.properties and\n                    custom_hunting_rule.properties.display_name and\n                    custom_hunting_rule.properties.display_name in names\n                ]\n\n            if tactics:\n                conditions += [\n                    custom_hunting_rule.properties and\n                    custom_hunting_rule.properties.tactics and\n                    any([tactic in tactics for tactic in custom_hunting_rule.properties.tactics])\n                ]\n\n            if all(conditions):\n                filtered_custom_hunting_rules.append(custom_hunting_rule)\n\n        return filtered_custom_hunting_rules\n\n    @staticmethod\n    def validate_login_response(response, error_msg=\"An error occurred\"):\n        # type: (requests.Response, str) -> None\n        \"\"\"\n        Login Response Validation\n        @param response: API Response\n        @param error_msg: Error message to change raised one\n        \"\"\"\n        try:\n            response.raise_for_status()\n\n        except requests.HTTPError as error:\n            raise MicrosoftAzureSentinelManagerError(\n                \"{error_msg}: {error} {text}\".format(\n                    error_msg=error_msg,\n                    error=error,\n                    text=response.json().get(\"error_description\", response.content)\n                )\n            )\n\n    @staticmethod\n    def validate_iso8601_duration(duration):\n        # type: (str) -> None or MicrosoftAzureSentinelValidationError\n        \"\"\"\n        Validate iso8601 duration\n        @param duration: Duration in ISO8601 format\n        \"\"\"\n        if not duration:\n            return\n\n        try:\n            isodate.parse_duration(duration)\n        except isodate.ISO8601Error:\n            raise MicrosoftAzureSentinelValidationError(f'Time duration format \\\"{duration}\\\" is invalid')\n\n    @classmethod\n    def validate_duration(cls, duration):\n        try:\n            if not duration:\n                return\n\n            duration = isodate.parse_duration(duration)\n\n            # In case we are using more than month duration, isodate.parse_duration returns Duration type\n            if not isinstance(duration, timedelta):\n                # Start time to use totimedelta function to calculate days in month to properly get total_seconds\n                duration = duration.totimedelta(datetime.utcnow())\n\n            if not MIN_PT_DURATION.total_seconds() <= duration.total_seconds() <= MAX_PT_DURATION.total_seconds():\n                raise MicrosoftAzureSentinelValidationError(\n                    f'Duration can be only between {MIN_PT_DURATION} and {MAX_PT_DURATION}\\n')\n        except isodate.ISO8601Error:\n            raise MicrosoftAzureSentinelValidationError('Time duration format \\\"{}\\\" is invalid'.format(duration))\n\n    @classmethod\n    def validate_sequence(cls, items, default, sec_name):\n        # type: (list, list, str) -> None or MicrosoftAzureSentinelValidationError\n        \"\"\"\n        Validate if statuses are a possible values\n        @param items: items ti validate\n        @param default: acceptable items\n        @param sec_name: acceptable items\n        \"\"\"\n        if not items:\n            return\n\n        items = set(items)\n        default_statuses = set(default)\n        wrong_statuses = items ^ default_statuses & items\n        if wrong_statuses:\n            raise MicrosoftAzureSentinelValidationError(\n                f'Wrong {sec_name} {convert_list_to_comma_separated_string(wrong_statuses)}.\\nPossible values '\n                f'are {convert_list_to_comma_separated_string(default_statuses)}')\n\n    @classmethod\n    def validate_statuses(cls, statuses, additional_defaults=None):\n        cls.validate_sequence(statuses, DEFAULT_STATUSES + (additional_defaults or []), 'statuses')\n\n    @classmethod\n    def validate_incident_statuses(cls, statuses, additional_defaults=None):\n        cls.validate_sequence(statuses, DEFAULT_UPDATE_INCIDENT_STATUSES + (additional_defaults or []), 'statuses')\n\n    @classmethod\n    def validate_severities(cls, severities, additional_defaults=None):\n        cls.validate_sequence(severities, DEFAULT_SEVERITIES + (additional_defaults or []), 'severities')\n\n    @classmethod\n    def validate_alert_rule_severities(cls, severities, additional_defaults=None):\n        cls.validate_sequence(severities, DEFAULT_ALERT_RULE_SEVERITIES + (additional_defaults or []), 'severities')\n\n    @classmethod\n    def validate_tactics(cls, tactics, additional_defaults=None):\n        cls.validate_sequence(tactics, DEFAULT_TACTICS + (additional_defaults or []), 'tactics')\n\n    @classmethod\n    def validate_trigger_operators(cls, trigger_operators, additional_defaults=None):\n        cls.validate_sequence(trigger_operators, DEFAULT_TRIGGER_OPERATORS + (additional_defaults or []), 'trigger')\n\n    @classmethod\n    def validate_close_reasons(cls, close_reasons, additional_defaults=None):\n        cls.validate_sequence(close_reasons, DEFAULT_CLOSE_REASONS + (additional_defaults or []), 'close_reasons')\n\n    # @TODO remove after refactor\n    @staticmethod\n    def convert_comma_separated_to_list(comma_separated):\n        # type: (str) -> list\n        \"\"\"\n        Convert comma-separated string to list\n        @param comma_separated: String with comma-separated values\n        @return: List of values\n        \"\"\"\n        return [item.strip() for item in comma_separated.split(',')] if comma_separated else []\n\n    @staticmethod\n    def join_validation_errors(validation_errors):\n        # type: (list) -> str\n        \"\"\"\n        Join validation errors list to one string\n        @param validation_errors: Validation error messages list\n        \"\"\"\n        return '\\n'.join(validation_errors)\n\n    @staticmethod\n    def convert_list_to_comma_separated_string(iterable):\n        # type: (list or set) -> str\n        \"\"\"\n        Convert list to comma separated string\n        @param iterable: List or Set to covert\n        \"\"\"\n        return ', '.join(iterable)\n    \n    def get_incident_comments(self, incident_number):\n        params = {\n            'api-version': self._get_endpoint_version('incident_comments'),\n        }\n        endpoint = API_ENDPOINTS[\"incident_comments\"][\"url\"].format(incident_number)\n        url = f'{self.base_url}{endpoint}'\n        response = self.session.get(url, params=params)\n        \n        return response.json()[\"value\"]\n        \n        \n    \n    def get_updated_incidents(self, updated_time=None, limit=None):\n        # type: (datetime, int, list, list, int, bool) -> [object]\n        \"\"\"\n        Get all Incidents including filters\n        @param updated_time: Get incidents with updatedUtc time greater than passed datetime\n        \"\"\"\n        params = {\n            'api-version': self._get_endpoint_version('incidents'),\n        }\n        \n\n        query = f\"(properties/lastModifiedTimeUtc ge {updated_time.strftime(TIME_FORMAT)} and properties/lastModifiedTimeUtc ne properties/createdTimeUtc)\"\n        \n        if query:\n            params[QueryFilterKeyEnum.FILTER.value] = query\n        \n        if limit:\n            params[QueryFilterKeyEnum.LIMIT.value] = limit\n\n        response = self.session.get(self._get_full_url('incidents'), params=params)\n        self.validate_response(response)\n        return self.sentinel_parser.build_results(response.json(), 'build_siemplify_incident_obj', limit=limit)\n    \n    def get_incident_entities(self, alert_id, incident_number, incident_id, backlog_ids):\n        \"\"\"\n        Get Azure Sentinel entities related to specific incident.\n        :param alert_id: {str} Id of the alert\n        :param incident_number: {int} The number of the incident\n        :param incident_id: {str} ID of the incident\n        :param backlog_ids: {dict} Backlog ids dict\n        :return: {list} List of Entity objects\n        \"\"\"\n        url = '{}{}'.format(self.base_url, API_ENDPOINTS['GET_INCIDENT_ENTITIES']['URL'].format(incident_id=incident_id))\n\n        params = {\n            'api-version': API_ENDPOINTS['GET_INCIDENT_ENTITIES']['VERSION']\n        }\n\n        response = self.session.post(url, params=params)\n\n        try:\n            self.validate_response(response)\n        except Exception as e:\n            if isinstance(e, MicrosoftAzureSentinelTimeoutError):\n                raise\n            if incident_number not in backlog_ids:\n                self.logger.error(\"Failed to fetch alert {} entities. Will send it to backlog. Incident {}\".\n                                  format(alert_id, incident_id))\n            return None\n\n        response_data = response.json()\n        edges_data = response_data.get('edges', [])\n\n        return [self.sentinel_parser.build_siemplify_alert_entity_obj(\n                    entity_data,\n                    next((edge.get('additionalData', {}) for edge in edges_data\n                         if edge.get('targetEntityId') == entity_data.get('id')), None)\n                ) for entity_data in response_data.get('entities', [])]\n",
            "description": "Script of integration manager",
            "type": 12,
            "mode": 0,
            "isDisplayed": false,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "VendorFieldFallback",
            "paramValue": "vendorName",
            "description": "Specify a comma separated list of incident attributes that should be used as a fallback for the \"DeviceVendor\" field in descending order. First attribute will have the highest priority, next if its not present or empty in the event - fallback to the next value from the list and so on.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "StartTimeFallback",
            "paramValue": "properties_firstActivityTimeGenerated,properties_startTimeUtc,properties_createdTimeUtc,properties_firstAlertTimeGenerated",
            "description": "Specify a comma separated list of incident or alert attributes that should be used as a fallback for the \u201cStart Time\u201d alert field in descending order. Additionally, new \u201cSiemplify_Start_Time\u201c attribute will be added to created events. First attribute will have the highest priority, next if its not present or empty in the event - fallback to the next value from the list and so on. If none of the fallback fields are found, connector will use createdTimeUTC, and if that's also non existent - alert ingestion time to Siemplify.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "API Root",
            "paramValue": "https://management.azure.com",
            "description": "The API Root of Microsoft Azure Sentinel REST API root.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "OAUTH2 Login Endpoint Url",
            "paramValue": "https://login.microsoftonline.com",
            "description": "Specify the url, that connector should use for OAUTH2 Login.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "Azure Resource Group",
            "paramValue": "securityservices-test-rg",
            "description": "Name of Azure Resource Group where Azure Sentinel is located.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "Azure Sentinel Workspace Name",
            "paramValue": "NBSentinel-test-ws",
            "description": "Name of the Azure Sentinel workspace to work with, can be viewed in Azure portal > Azure Sentinel > Azure Sentinel Workspaces.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "Client ID",
            "paramValue": "d6e44bc6-5550-4978-8fa7-8f93c38c6222",
            "description": "Client (Application) ID that was added for the app registration in Azure Active Directory for this integration.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "Client Secret",
            "paramValue": "***************",
            "description": "Secret that was entered for Azure AD app registration",
            "type": 3,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "Verify SSL",
            "paramValue": "false",
            "description": "Verify SSL certificates for HTTPS requests to Microsoft Azure.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "Max New Incidents Per Cycle",
            "paramValue": "10",
            "description": "How many incidents should be processed during one connector run",
            "type": 1,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "Max Backlog Incidents per cycle",
            "paramValue": "10",
            "description": "How many incidents  connector should try to fetch from the backlog during one connector run.",
            "type": 1,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "Offset Time In Hours",
            "paramValue": "24",
            "description": "Fetch alerts from X hours backwards. Default value: 24 hours.",
            "type": 1,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "Incident Statuses to Fetch",
            "paramValue": "New, Active, Closed",
            "description": "Specify the statuses of the incidents that should be fetched by the Siemplify server. Parameter can take multiple values as a comma separated string.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "Incident Severities to Fetch",
            "paramValue": "Informational, Low, Medium, High",
            "description": "Specify the severities of the incidents that should be fetched by the Siemplify server. Parameter can take multiple values as a comma separated string.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "Use the same approach with event creation for all alert types?",
            "paramValue": "false",
            "description": "By default connector uses a different approach with Scheduled Alert or NRT types of alerts - it tries to fetch events that caused the alert by running the query specified in alert details. Specify whether to change this behavior and use the same approach for the scheduled and NRT alerts as for other alert types.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "Use whitelist as a blacklist",
            "paramValue": "false",
            "description": "If enabled, whitelist will be used as a blacklist.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "EventFieldFallback",
            "paramValue": "kind",
            "description": "Specify a comma separated list of alert attributes that should be used as a fallback for the \"Event Field Name\" parameter in descending order. First attribute will have the highest priority, next if its not present or empty in the event - fallback to the next value from the list and so on.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "ProductFieldFallback",
            "paramValue": "ProductName",
            "description": "Specify a comma separated list of incident or alert attributes that should be used as a fallback for the \"Product Field Name\" parameter and \"DeviceProduct\" field in descending order. First attribute will have the highest priority, next if its not present or empty in the event - fallback to the next value from the list and so on.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "Enable Fallback Logic Debug?",
            "paramValue": "false",
            "description": "Specify if connector should add to the created events a \u201cdebug\u201c fields that will contain the values it used for fallback.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "EndTimeFallback",
            "paramValue": "properties_lastActivityTimeGenerated,properties_endTimeUtc,properties_createdTimeUtc,properties_lastAlertTimeGenerated",
            "description": "Specify a comma separated list of incident or alert attributes that should be used as a fallback for the \u201cEnd Time\u201d alert field in descending order. Additionally, new \u201cSiemplify_End_Time\u201c attribute will be added to created events. First attribute will have the highest priority, next if its not present or empty in the event - fallback to the next value from the list and so on. If none of the fallback fields are found, connector will use createdTimeUTC, and if that's also non existent - alert ingestion time to Siemplify.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "Create Siemplify Alerts for Sentinel incidents that do not have entities?",
            "paramValue": "true",
            "description": "If enabled, connector will create Siemplify alerts from Microsoft Sentinel incidents that dont have entities. Otherwise, such incidents will be skipped for all Sentinel incidents types except Sentinel Scheduled and NRT alerts.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "Incident's Alerts Limit to Ingest",
            "paramValue": "10",
            "description": "Specify the maximum number of  alerts the connector should ingest per a single Azure Sentinel incident.",
            "type": 1,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "Proxy Server Address",
            "paramValue": "",
            "description": "Proxy server to use for connection.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "Proxy Username",
            "paramValue": "",
            "description": "Proxy server username",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "Proxy Password",
            "paramValue": "",
            "description": "Proxy server password",
            "type": 3,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "Incidents Padding Period (minutes)",
            "paramValue": "",
            "description": "If specified, to get incidents returned not in chronological order, connector will fetch Sentinel incidents from this value backwards in time.",
            "type": 1,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "Alert Name Template",
            "paramValue": "",
            "description": "If specified, connector will use this value from the Microsoft Azure Sentinel API response for incident data for Siemplify Alert Name. You can provide placeholders in the following format: [name of the field]. Example: Sentinel incident - [title]. Note: the maximum length for the field is 256 characters. If nothing is provided or user provides an invalid template, connector will use the default alert name.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        },
        {
            "connectorIdentifier": null,
            "paramName": "Rule Generator Template",
            "paramValue": "",
            "description": "If specified, connector will use this value from the Microsoft Azure Sentinel API response for incident data for Siemplify Rule Generator. You can provide placeholders in the following format: [name of the field]. Example: Sentinel incident - [severity]. Note: the maximum length for the field is 256 characters. If nothing is provided or user provides an invalid template, connector will use the default rule generator value.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1671079987259,
            "modificationTimeUnixTimeInMs": 1671079987259
        }
    ],
    "allowList": [],
    "integrationVersion": 26.0,
    "isScriptConnector": true,
    "script": "import sys\nimport json\nfrom datetime import timedelta\n\nfrom SiemplifyConnectors import SiemplifyConnectorExecution\nfrom SiemplifyConnectorsDataModel import AlertInfo\nfrom SiemplifyUtils import output_handler, utc_now, convert_string_to_unix_time, unix_now, convert_string_to_datetime\nfrom MicrosoftAzureSentinelManager import MicrosoftAzureSentinelManager\nfrom MicrosoftAzureSentinelCommon import (\n    MicrosoftAzureSentinelCommon,\n    is_date,\n    validate_backlog,\n    validate_incidents_numbers,\n    validate_alerts_next_page,\n    read_backlog_ids,\n    read_next_page_alerts,\n    read_incidents_numbers,\n    write_next_page_alerts,\n    write_incidents_numbers,\n    write_backlog_ids\n)\nfrom MicrosoftAzureSentinelParser import MicrosoftAzureSentinelParser\nfrom EnvironmentCommon import GetEnvironmentCommonFactory\nfrom TIPCommon import (\n    extract_connector_param,\n    dict_to_flat,\n    is_overflowed,\n    siemplify_fetch_timestamp,\n    siemplify_save_timestamp,\n    validate_timestamp,\n    read_ids_by_timestamp,\n    write_ids_with_timestamp\n)\nfrom exceptions import TimeoutIsApproachingError\nfrom utils import handle_special_characters, get_value_from_template\n\nfrom constants import NRT_ALERT_TYPE_STRING, NRT_ALERT_EVENT_KIND, SCHEDULED_ALERT_EVENT_KIND\n\nCONNECTOR_NAME = \"Microsoft Azure Sentinel Incidents Connector v2\"\nDEFAULT_VENDOR_NAME = 'MicrosoftAzureSentinel'\nDEFAULT_PRODUCT_NAME = 'Product Name'\nDEFAULT_PROVIDER_NAME = 'Provider Name'\nWHITELIST_FILTER = 'whitelist'\nBLACKLIST_FILTER = 'blacklist'\nMAX_INCIDENTS_PER_CYCLE = 10\nMAX_BACKLOG_INCIDENTS_PER_CYCLE = 10\nSCHEDULED_ALERTS_EVENTS_DEFAULT_LIMIT = 100\nMAX_INCIDENTS_NUMBERS_TO_SAVE = 1000\nconnector_starting_time = unix_now()\nDEFAULT_INCIDENTS_ALERTS_LIMIT_TO_INGEST = 10\n\n\n@output_handler\ndef main(is_test_run):\n    all_alerts = []\n    processed_alerts = []\n    siemplify = SiemplifyConnectorExecution()\n    siemplify.script_name = CONNECTOR_NAME\n\n    try:\n        if is_test_run:\n            siemplify.LOGGER.info(\"***** This is an \\\"IDE Play Button\\\" \\\"Run Connector once\\\" test run ******\")\n\n        siemplify.LOGGER.info(\"==================== Main - Param Init ====================\")\n\n        environment = extract_connector_param(\n            siemplify,\n            param_name='Environment Field Name',\n            print_value=True\n        )\n\n        environment_regex = extract_connector_param(\n            siemplify,\n            param_name='Environment Regex Pattern',\n            print_value=True\n        )\n\n        subscription_id = extract_connector_param(\n            siemplify,\n            param_name='Azure Subscription ID',\n            is_mandatory=True,\n            print_value=True\n        )\n\n        tenant_id = extract_connector_param(\n            siemplify,\n            param_name='Azure Active Directory ID',\n            is_mandatory=True,\n            print_value=True\n        )\n\n        api_root = extract_connector_param(\n            siemplify,\n            param_name='API Root',\n            is_mandatory=True,\n            print_value=True\n        )\n\n        login_url = extract_connector_param(\n            siemplify,\n            param_name='OAUTH2 Login Endpoint Url',\n            is_mandatory=True,\n            print_value=True\n        )\n\n        resource = extract_connector_param(\n            siemplify,\n            param_name='Azure Resource Group',\n            is_mandatory=True,\n            print_value=True\n        )\n\n        workspace_id = extract_connector_param(\n            siemplify,\n            param_name='Azure Sentinel Workspace Name',\n            is_mandatory=True,\n            print_value=True\n        )\n\n        client_id = extract_connector_param(\n            siemplify,\n            param_name='Client ID',\n            is_mandatory=True,\n            print_value=True\n        )\n\n        client_secret = extract_connector_param(\n            siemplify,\n            param_name='Client Secret',\n            is_mandatory=True,\n            print_value=False\n        )\n\n        verify_ssl = extract_connector_param(\n            siemplify,\n            param_name='Verify SSL',\n            input_type=bool,\n            print_value=True\n        )\n\n        limit = extract_connector_param(\n            siemplify,\n            param_name='Max New Incidents Per Cycle',\n            input_type=int,\n            is_mandatory=True,\n            print_value=True,\n            default_value=MAX_INCIDENTS_PER_CYCLE\n        )\n        limit = limit and max(0, limit)\n\n        offset_hours = extract_connector_param(\n            siemplify,\n            param_name='Offset Time In Hours',\n            input_type=int,\n            is_mandatory=True,\n            print_value=True\n        )\n\n        statuses = extract_connector_param(\n            siemplify,\n            param_name='Incident Statuses to Fetch',\n            is_mandatory=True,\n            print_value=True\n        )\n\n        severities = extract_connector_param(\n            siemplify,\n            param_name='Incident Severities to Fetch',\n            is_mandatory=True,\n            print_value=True\n        )\n\n        use_same_approach = extract_connector_param(\n            siemplify,\n            param_name='Use the same approach with event creation for all alert types?',\n            input_type=bool,\n            print_value=True\n        )\n\n        python_process_timeout = extract_connector_param(\n            siemplify, param_name=\"PythonProcessTimeout\",\n            input_type=int,\n            is_mandatory=True,\n            print_value=True\n        )\n\n        alerts_padding_period = extract_connector_param(\n            siemplify,\n            param_name='Alerts Padding Period',\n            input_type=int,\n            is_mandatory=True,\n            print_value=True\n        )\n\n        incidents_padding_period = extract_connector_param(\n            siemplify,\n            param_name='Incidents Padding Period (minutes)',\n            input_type=int,\n            print_value=True\n        )\n\n        whitelist_as_a_blacklist = extract_connector_param(\n            siemplify,\n            param_name='Use whitelist as a blacklist',\n            is_mandatory=True,\n            input_type=bool,\n            print_value=True\n        )\n\n        event_field_fallback = extract_connector_param(\n            siemplify,\n            param_name='EventFieldFallback',\n            is_mandatory=True,\n            print_value=True\n        )\n\n        product_field_fallback = extract_connector_param(\n            siemplify,\n            param_name='ProductFieldFallback',\n            is_mandatory=True,\n            print_value=True\n        )\n\n        vendor_field_fallback = extract_connector_param(\n            siemplify,\n            param_name='VendorFieldFallback',\n            is_mandatory=True,\n            print_value=True\n        )\n\n        start_time_fallback = extract_connector_param(\n            siemplify,\n            param_name='StartTimeFallback',\n            is_mandatory=True,\n            print_value=True\n        )\n\n        end_time_fallback = extract_connector_param(\n            siemplify,\n            param_name='EndTimeFallback',\n            is_mandatory=True,\n            print_value=True\n        )\n\n        fallback_logic_debug = extract_connector_param(\n            siemplify,\n            param_name='Enable Fallback Logic Debug?',\n            input_type=bool,\n            print_value=True\n        )\n\n        max_backlog_limit_per_cycle = extract_connector_param(\n            siemplify,\n            param_name='Max Backlog Incidents per cycle',\n            input_type=int,\n            print_value=True,\n            default_value=MAX_BACKLOG_INCIDENTS_PER_CYCLE\n        )\n\n        scheduled_alerts_events_limit = extract_connector_param(\n            siemplify,\n            param_name='Scheduled Alerts Events Limit to Ingest',\n            input_type=int,\n            print_value=True,\n            default_value=SCHEDULED_ALERTS_EVENTS_DEFAULT_LIMIT\n        )\n\n        alerts_for_no_entities = extract_connector_param(\n            siemplify,\n            param_name='Create Siemplify Alerts for Sentinel incidents that do not have entities?',\n            input_type=bool,\n            print_value=True\n        )\n\n        incidents_alerts_limit_to_ingest = extract_connector_param(\n            siemplify,\n            param_name=\"Incident's Alerts Limit to Ingest\",\n            input_type=int,\n            print_value=True,\n            default_value=DEFAULT_INCIDENTS_ALERTS_LIMIT_TO_INGEST\n        )\n\n        alert_name_template = extract_connector_param(\n            siemplify,\n            param_name=\"Alert Name Template\",\n            input_type=str,\n            print_value=True,\n            is_mandatory=False\n        )\n        rule_generator_template = extract_connector_param(\n            siemplify,\n            param_name=\"Rule Generator Template\",\n            input_type=str,\n            print_value=True,\n            is_mandatory=False\n        )\n\n        whitelist_filter_type = BLACKLIST_FILTER if whitelist_as_a_blacklist else WHITELIST_FILTER\n\n        whitelist = [handle_special_characters(item) for item in siemplify.whitelist]\n\n        event_field_fallback = MicrosoftAzureSentinelManager.convert_comma_separated_to_list(event_field_fallback)\n        product_field_fallback = MicrosoftAzureSentinelManager.convert_comma_separated_to_list(product_field_fallback)\n        vendor_field_fallback = MicrosoftAzureSentinelManager.convert_comma_separated_to_list(vendor_field_fallback)\n        start_time_fallback = MicrosoftAzureSentinelManager.convert_comma_separated_to_list(start_time_fallback)\n        end_time_fallback = MicrosoftAzureSentinelManager.convert_comma_separated_to_list(end_time_fallback)\n        statuses = MicrosoftAzureSentinelManager.convert_comma_separated_to_list(statuses)\n        severities = MicrosoftAzureSentinelManager.convert_comma_separated_to_list(severities)\n\n        siemplify.LOGGER.info(\"------------------- Main - Started -------------------\")\n\n        if incidents_padding_period is not None and incidents_padding_period < 0:\n            raise Exception(f\"\\\"Incidents Padding Period (minutes)\\\" must be non-negative\")\n\n        environment_common = GetEnvironmentCommonFactory.create_environment_manager(\n            siemplify, environment, environment_regex)\n        sentinel_common = MicrosoftAzureSentinelCommon(siemplify.LOGGER)\n\n        validate_backlog(siemplify)\n        validate_alerts_next_page(siemplify)\n        validate_incidents_numbers(siemplify)\n\n        # reading backlog_ids file\n        siemplify.LOGGER.info(\"Reading backlog IDs\")\n        backlog_ids = read_backlog_ids(siemplify)\n        siemplify.LOGGER.info(f\"Number of items in backlog IDs: {len(backlog_ids.items())}\")\n\n        if is_test_run:\n            siemplify.LOGGER.info(\"This is a test run. Ignoring stored timestamps\")\n            last_success_time_datetime = validate_timestamp(utc_now() - timedelta(hours=offset_hours), offset_hours)\n        else:\n            last_success_time_datetime = validate_timestamp(\n                siemplify_fetch_timestamp(siemplify, datetime_format=True), offset_hours)\n\n        if incidents_padding_period is not None \\\n                and last_success_time_datetime > utc_now() - timedelta(minutes=incidents_padding_period):\n            last_success_time_datetime = utc_now() - timedelta(minutes=incidents_padding_period)\n            siemplify.LOGGER.info(f\"Last success time is greater than incidents padding period. Unix: \"\n                                  f\"{last_success_time_datetime.timestamp()} will be used as last success time\")\n\n        # Read already existing alerts ids\n        siemplify.LOGGER.info(\"Reading IDs\")\n        existing_ids = read_ids_by_timestamp(siemplify, convert_to_milliseconds=True)\n        siemplify.LOGGER.info(f\"Number of items IDs: {len(existing_ids.items())}\")\n\n        sentinel_manager = MicrosoftAzureSentinelManager(\n            api_root=api_root,\n            client_id=client_id,\n            client_secret=client_secret,\n            tenant_id=tenant_id,\n            workspace_id=workspace_id,\n            resource=resource,\n            subscription_id=subscription_id,\n            login_url=login_url,\n            verify_ssl=verify_ssl,\n            logger=siemplify.LOGGER\n        )\n\n        siemplify.LOGGER.info(\"Reading page link\")\n        next_page_link = read_next_page_alerts(siemplify)\n\n        fetched_alerts, next_page_link = sentinel_manager.get_incidents_with_new_endpoint(\n            creation_time=last_success_time_datetime,\n            statuses=statuses,\n            severities=severities,\n            limit=limit,\n            asc=True,\n            use_same_approach=use_same_approach,\n            existing_ids=existing_ids,\n            next_page_link=next_page_link,\n            connector_starting_time=connector_starting_time,\n            python_process_timeout=python_process_timeout,\n            scheduled_alerts_events_limit=scheduled_alerts_events_limit,\n            incidents_alerts_limit_to_ingest=incidents_alerts_limit_to_ingest,\n            backlog_ids=backlog_ids,\n        )\n        siemplify.LOGGER.info(f\"Number of fetched alerts: {len(fetched_alerts)}\")\n\n        filtered_alerts = sentinel_common.filter_old_ids(fetched_alerts, existing_ids)\n        siemplify.LOGGER.info(f\"Number of filtered alerts by ID: {len(filtered_alerts)}\")\n\n        if filtered_alerts:\n            if filtered_alerts[-1].properties.created_time_unix > last_success_time_datetime.timestamp():\n                siemplify.LOGGER.info(\"Writing next page\")\n                write_next_page_alerts(siemplify, '')\n\n        elif next_page_link:\n            siemplify.LOGGER.info(f\"Writing next page\")\n            write_next_page_alerts(siemplify, json.dumps(next_page_link))\n\n        else:\n            siemplify.LOGGER.info(\"Writing next page\")\n            write_next_page_alerts(siemplify, '')\n\n        siemplify.LOGGER.info(\"Found {} new alerts since {}.\"\n                              .format(len(filtered_alerts), last_success_time_datetime.isoformat()))\n\n        if is_test_run:\n            siemplify.LOGGER.info(\"This is a TEST run. Only 1 alert will be processed.\")\n            filtered_alerts = filtered_alerts[:1]\n\n        filtered_alerts = sorted(filtered_alerts, key=lambda _alert: _alert.properties.created_time_utc)\n        siemplify.LOGGER.info(f\"Number of sorted alerts: {len(filtered_alerts)}\")\n\n        fetched_backlog_alerts = []\n        while True:\n            if sentinel_common.is_approaching_timeout(connector_starting_time, python_process_timeout) or \\\n                    len(fetched_backlog_alerts) >= max_backlog_limit_per_cycle:\n                break\n            current_backlog_incidents = get_backlog_incidents(\n                sentinel_manager,\n                backlog_ids,\n                filtered_alerts,\n                limit=min(max_backlog_limit_per_cycle - len(fetched_backlog_alerts), 10),\n                use_same_approach=use_same_approach,\n                scheduled_alerts_events_limit=scheduled_alerts_events_limit\n            )\n            fetched_backlog_alerts.extend(current_backlog_incidents)\n            filtered_alerts.extend(current_backlog_incidents)\n            if not current_backlog_incidents:\n                break\n\n        siemplify.LOGGER.info(f'Fetched {len(fetched_backlog_alerts)} backlog alerts.')\n        siemplify.LOGGER.info(f'Total alerts to process {len(filtered_alerts)}')\n\n        alerts_to_backlog = []\n        alerts_to_create = []\n\n        siemplify.LOGGER.info(\"Reading incident numbers\")\n        existing_incidents_numbers = read_incidents_numbers(siemplify)\n        siemplify.LOGGER.info(f\"Number of incident numbers: {len(existing_incidents_numbers)}\")\n\n        for alert in filtered_alerts:\n            try:\n                siemplify.LOGGER.info(\"-------------- Started processing Alert {}\".format(alert.name),\n                                      alert_id=alert.name)\n\n                if sentinel_common.is_approaching_timeout(connector_starting_time, python_process_timeout):\n                    siemplify.LOGGER.info('Timeout is approaching. Connector will gracefully exit')\n                    break\n\n                # checking if fetched incidents contain entities\n                if use_same_approach or all(not isinstance(item, dict) for item in alert.properties.alerts):\n                    if all(item.entities or (alerts_for_no_entities and item.entities is not None)\n                           for item in alert.properties.alerts):\n                        if str(alert.properties.incident_number) in backlog_ids:\n                            if unix_now() < backlog_ids.get(\n                                    str(alert.properties.incident_number), 0) + alerts_padding_period * 60 * 1000:\n                                siemplify.LOGGER.info(\n                                    f'Backlog alert {alert.properties.incident_number} will be processed')\n                                alerts_to_create.append(alert)\n                            elif alerts_for_no_entities:\n                                siemplify.LOGGER.info(\"Expired backlog alert {} ({}) will be processed.\"\n                                                      .format(alert.name, alert.properties.incident_number))\n                                alerts_to_create.append(alert)\n                            else:\n                                siemplify.LOGGER.info(f'Backlog alert {alert.properties.incident_number} expired')\n\n                        else:\n                            siemplify.LOGGER.info(f'Regular alert {alert.properties.incident_number} will be processed')\n                            alerts_to_create.append(alert)\n                    else:\n                        if str(alert.properties.incident_number) not in backlog_ids:\n                            if not pass_whitelist_filter(siemplify, alert, whitelist, whitelist_filter_type):\n                                siemplify.LOGGER.info('Alert {} did not pass filters skipping....'.format(alert.name))\n                            else:\n                                siemplify.LOGGER.info(\"Sending alert {} ({}) to backlog\"\n                                                      .format(alert.name, alert.properties.incident_number))\n                                alerts_to_backlog.append(alert)\n                        elif alerts_for_no_entities and unix_now() >= backlog_ids.get(\n                                str(alert.properties.incident_number), 0) + alerts_padding_period * 60 * 1000:\n                            siemplify.LOGGER.info(\"Expired backlog alert {} ({}) with no entities will be \"\n                                                  \"processed.\".format(alert.name, alert.properties.incident_number))\n                            alerts_to_create.append(alert)\n                        else:\n                            siemplify.LOGGER.info(\"Alert {} ({}) is already in backlog\".format(\n                                alert.name, alert.properties.incident_number))\n\n                        siemplify.LOGGER.info('Finished processing Alert {}'.format(alert.name),\n                                              alert_id=alert.name)\n\n                ingested_alert_ids = [str(alert_to_create.properties.incident_number) for alert_to_create in\n                                      alerts_to_create]\n\n                siemplify.LOGGER.info(\"Updating processed alerts\")\n                processed_alerts.append(alert)\n                siemplify.LOGGER.info(f\"Number of processed alerts: {len(processed_alerts)}\")\n\n                if str(alert.properties.incident_number) not in ingested_alert_ids:\n                    if all(not isinstance(item, dict) for item in alert.properties.alerts):\n                        continue\n\n                    alerts_to_create.append(alert)\n\n                if not pass_whitelist_filter(siemplify, alert, whitelist, whitelist_filter_type):\n                    siemplify.LOGGER.info('Alert {} did not pass filters skipping....'.format(alert.name))\n                    continue\n\n                alert_info = create_alert_info(siemplify=siemplify,\n                                               environment_common=environment_common,\n                                               alert=alert,\n                                               vendor_field_fallback=vendor_field_fallback,\n                                               product_field_fallback=product_field_fallback,\n                                               event_field_fallback=event_field_fallback,\n                                               start_time_fallback=start_time_fallback,\n                                               end_time_fallback=end_time_fallback,\n                                               fallback_logic_debug=fallback_logic_debug,\n                                               use_same_approach=use_same_approach,\n                                               alert_name_template=alert_name_template,\n                                               rule_generator_template=rule_generator_template)\n\n                if is_overflowed(siemplify, alert_info, is_test_run):\n                    siemplify.LOGGER.info(\n                        '{alert_name}-{alert_identifier}-{environment}-{product} found as overflow alert. Skipping.'\n                            .format(alert_name=alert_info.rule_generator,\n                                    alert_identifier=alert_info.ticket_id,\n                                    environment=alert_info.environment,\n                                    product=alert_info.device_product))\n                    # If is overflowed we should skip\n                    continue\n\n                all_alerts.append(alert_info)\n                siemplify.LOGGER.info('Alert {} was created.'.format(alert.name))\n            except Exception as e:\n                siemplify.LOGGER.error(\"Failed to process alert {}\".format(alert.name), alert_id=alert.name)\n                siemplify.LOGGER.exception(e)\n\n                if is_test_run:\n                    raise\n\n            siemplify.LOGGER.info('Finished processing Alert {}'.format(alert.name), alert_id=alert.name)\n\n        if not is_test_run:\n            # Processing backlog\n            new_backlog = update_backlog(siemplify, alerts_to_create, backlog_ids,\n                                         alerts_to_backlog, alerts_padding_period)\n            if sorted(backlog_ids) != sorted(new_backlog):\n                siemplify.LOGGER.info(\"Writing backlog in main\")\n                write_backlog_ids(siemplify, new_backlog)\n                siemplify.LOGGER.info(f\"Number of IDs in written backlog: {len(new_backlog)}\")\n\n            # Processing timestamp\n            processed_alerts_with_timestamp = [\n                item for item in processed_alerts\n                if item.properties.created_time_utc\n                and str(item.properties.incident_number) not in new_backlog\n            ]\n\n            if processed_alerts_with_timestamp:\n                alerts_with_timestamp = sorted(processed_alerts_with_timestamp, key=lambda _alert: _alert.properties.\n                                               created_time_utc)\n                new_timestamp = alerts_with_timestamp[-1].properties.created_time_utc\n                siemplify_save_timestamp(siemplify, new_timestamp=(convert_string_to_unix_time(new_timestamp)))\n                siemplify.LOGGER.info(\n                    'New timestamp {} has been saved'\n                    .format(convert_string_to_datetime(new_timestamp).isoformat())\n                )\n\n            # Processing id files\n            new_existing_ids = {alert.name: unix_now() for alert in processed_alerts}\n            if new_existing_ids:\n                existing_ids.update(new_existing_ids)\n                siemplify.LOGGER.info(\"Writing IDs\")\n                write_ids_with_timestamp(siemplify, existing_ids)\n                siemplify.LOGGER.info(f\"Number of IDs to write: {len(existing_ids)}\")\n\n            new_existing_incidents_numbers = [alert.extensions[\"incidentNumber\"] for alert in all_alerts]\n            if new_existing_incidents_numbers:\n                existing_incidents_numbers.extend(new_existing_incidents_numbers)\n                existing_incidents_numbers = existing_incidents_numbers[-MAX_INCIDENTS_NUMBERS_TO_SAVE:]\n                siemplify.LOGGER.info(\"Writing incident-numbers\")\n                write_incidents_numbers(siemplify, existing_incidents_numbers)\n                siemplify.LOGGER.info(f\"Number of incidents-numbers to write: {len(existing_incidents_numbers)}\")\n\n    except TimeoutIsApproachingError:\n        siemplify.LOGGER.info('Timeout is approaching. Connector will gracefully exit')\n    except Exception as e:\n        siemplify.LOGGER.error(f'Got exception on main handler. Error: {e}')\n        siemplify.LOGGER.exception(e)\n\n        if is_test_run:\n            raise\n\n    siemplify.LOGGER.info(\"Created total of {} cases\".format(len(all_alerts)))\n    siemplify.LOGGER.info(\"------------------- Main - Finished -------------------\")\n    siemplify.return_package(all_alerts)\n\n\ndef update_backlog(siemplify, alerts_to_create, backlog_ids, alerts_to_backlog,\n                   alerts_padding_period):\n    new_backlog = {}\n    ingested_alert_ids = [\n        str(alert_to_create.properties.incident_number)\n        for alert_to_create in alerts_to_create\n    ]\n\n    for alert_num, time in backlog_ids.items():\n        if alert_num not in ingested_alert_ids and unix_now() < time + alerts_padding_period * 60 * 1000:\n            siemplify.LOGGER.info(\n                f'Keeping {alert_num} in backlog...')\n            new_backlog[alert_num] = time\n\n    for backlog_alert in alerts_to_backlog:\n        incident_number = str(backlog_alert.properties.incident_number)\n        if incident_number not in new_backlog:\n            new_backlog[incident_number] = unix_now()\n    return new_backlog\n\n\ndef get_backlog_incidents(sentinel_manager, backlog_ids, filtered_alerts,\n                          limit=MAX_BACKLOG_INCIDENTS_PER_CYCLE, use_same_approach=False,\n                          scheduled_alerts_events_limit=None):\n    incidents = []\n\n    counter = 0\n    for inc_number in backlog_ids:\n        if counter >= limit:\n            break\n\n        if inc_number not in [str(incident.properties.incident_number) for incident in filtered_alerts]:\n            incidents.append(sentinel_manager.get_incident_by_number(\n                incident_number=inc_number,\n                use_same_approach=use_same_approach,\n                scheduled_alerts_events_limit=scheduled_alerts_events_limit,\n                backlog_ids=backlog_ids))\n            counter += 1\n\n    return incidents\n\n\ndef create_alert_info(siemplify, environment_common, alert, vendor_field_fallback, product_field_fallback,\n                      event_field_fallback, start_time_fallback, end_time_fallback, fallback_logic_debug,\n                      use_same_approach=False, alert_name_template=\"\", rule_generator_template=\"\"):\n    flat_incident = alert.raw_to_flat_data()\n    alert_info = AlertInfo()\n\n    alert_info.display_id = alert.name\n    alert_info.ticket_id = alert.name\n    alert_info.name = get_value_from_template(\n        template=alert_name_template,\n        data=flat_incident,\n        default_value=alert.properties.title,\n    )\n    alert_info.rule_generator = get_value_from_template(\n        template=rule_generator_template,\n        data=flat_incident,\n        default_value=alert.properties.title,\n    )\n    alert_info.description = alert.properties.description\n    alert_info.priority = MicrosoftAzureSentinelParser.calculate_priority(alert.properties.severity)\n\n    start_time = alert.properties.created_time_utc\n    end_time = alert.properties.created_time_utc\n\n    for item in start_time_fallback:\n        if flat_incident.get(item):\n            start_time = flat_incident[item]\n            if fallback_logic_debug:\n                flat_incident[\"StartTimeFallback\"] = item\n            break\n\n    for item in end_time_fallback:\n        if flat_incident.get(item):\n            end_time = flat_incident[item]\n            if fallback_logic_debug:\n                flat_incident[\"EndTimeFallback\"] = item\n            break\n\n    if start_time:\n        alert_info.start_time = convert_string_to_unix_time(start_time)\n        if fallback_logic_debug and not flat_incident.get(\"StartTimeFallback\"):\n            flat_incident[\"StartTimeFallback\"] = \"CreatedTimeUTC\"\n    else:\n        alert_info.start_time = unix_now()\n        siemplify.LOGGER.info(\"Siemplify Alert's start time is set to current time, as no values were found with the \"\n                              \"provided fallback fields.\")\n        if fallback_logic_debug:\n            flat_incident[\"StartTimeFallback\"] = \"Current time\"\n\n    if end_time:\n        alert_info.end_time = convert_string_to_unix_time(end_time)\n        if fallback_logic_debug and not flat_incident.get(\"EndTimeFallback\"):\n            flat_incident[\"EndTimeFallback\"] = \"CreatedTimeUTC\"\n    else:\n        alert_info.end_time = unix_now()\n        siemplify.LOGGER.info(\"Siemplify Alert's end time is set to current time, as no values were found with the \"\n                              \"provided fallback fields.\")\n        if fallback_logic_debug:\n            flat_incident[\"EndTimeFallback\"] = \"Current time\"\n\n    if alert.properties.alerts:\n        source_alert = alert.properties.alerts[0]\n        if isinstance(source_alert, dict):\n            device_vendor = source_alert.get(\"VendorName\")\n            device_product = source_alert.get(\"ProductName\")\n        else:\n            device_vendor = source_alert.properties.vendor_name\n            device_product = source_alert.properties.product_name\n    else:\n        product_value = None\n        vendor_value = None\n\n        for item in product_field_fallback:\n            if flat_incident.get(item):\n                product_value = flat_incident[item]\n                if fallback_logic_debug:\n                    flat_incident[\"ProductFieldFallback\"] = item\n                break\n\n        for item in vendor_field_fallback:\n            if flat_incident.get(item):\n                vendor_value = flat_incident[item]\n                if fallback_logic_debug:\n                    flat_incident[\"VendorFieldFallback\"] = item\n                break\n\n        device_vendor = vendor_value if vendor_value else DEFAULT_VENDOR_NAME\n        device_product = product_value if product_value else DEFAULT_PRODUCT_NAME\n\n    alert_info.device_vendor = device_vendor\n    alert_info.device_product = device_product\n\n    alert_info.extensions = dict_to_flat({\n        'status': alert.properties.status,\n        'labels': [str(label) for label in alert.properties.labels],\n        'endTimeUtc': alert.properties.end_time_utc,\n        'startTimeUtc': alert.properties.start_time_utc,\n        'owner': alert.properties.owner.assigned_to if alert.properties.owner else None,\n        'lastModifiedTimeUtc': alert.properties.last_modified_time_utc,\n        'createdTimeUtc': alert.properties.created_time_utc,\n        'incidentNumber': alert.properties.incident_number,\n        'additionalData': alert.properties.additional_data\n    })\n    events = [] if alert.properties.alerts else [alert.to_event()]\n\n    for incident_alert in alert.properties.alerts:\n        if isinstance(incident_alert, dict) and not use_same_approach:\n            # Need to \"unwrap\" the alert with the events that were fetched for it by its query\n            alert_events = incident_alert.get('Events', [])\n\n            if alert_events:\n                for event in alert_events:\n                    event[\"kind\"] = NRT_ALERT_EVENT_KIND \\\n                        if incident_alert.get('ProductComponentName') == NRT_ALERT_TYPE_STRING \\\n                        else SCHEDULED_ALERT_EVENT_KIND\n\n                events.extend(alert_events)\n\n            else:\n                # No events in the ASI alert - use the alert itself as the event\n                incident_alert[\"kind\"] = NRT_ALERT_EVENT_KIND \\\n                        if incident_alert.get('ProductComponentName') == NRT_ALERT_TYPE_STRING \\\n                        else SCHEDULED_ALERT_EVENT_KIND\n                events.append(incident_alert)\n        else:\n            # Use the alert itself as the event\n            events.append(incident_alert.to_event())\n            entities_to_events = incident_alert.entities or []\n\n            for entity in entities_to_events:\n                if entity.kind not in [\"Account\", \"Mailbox\", \"Host\", \"Ip\"]:\n                    continue\n\n                entity.raw_data[entity.kind] = entity.get_value()\n                for key, value in incident_alert.raw_data['properties'].items():\n                    if isinstance(value, str) and is_date(value):\n                        entity.raw_data['properties'][key] = value\n                events.append(entity.raw_data)\n\n    alert_info.events = list(map(dict_to_flat, events))\n    alert_info.environment = environment_common.get_environment(dict_to_flat(alert.raw_data))\n\n    for event in alert_info.events:\n        for item in event_field_fallback:\n            if event.get(item):\n                event['event_type'] = event[item]\n                if fallback_logic_debug:\n                    event[\"EventFieldFallback\"] = item\n                break\n        for item in product_field_fallback:\n            if event.get(item):\n                event['product_type'] = event[item]\n                if fallback_logic_debug:\n                    event[\"ProductFieldFallback\"] = item\n                break\n            elif flat_incident.get(item):\n                event['product_type'] = flat_incident[item]\n                if fallback_logic_debug:\n                    event[\"ProductFieldFallback\"] = item\n                break\n\n        event_start_time = alert.properties.created_time_utc\n        event_end_time = alert.properties.created_time_utc\n        for item in start_time_fallback:\n            if event.get(item):\n                event_start_time = event[item]\n                if fallback_logic_debug:\n                    event[\"StartTimeFallback\"] = item\n                break\n        for item in end_time_fallback:\n            if event.get(item):\n                event_end_time = event[item]\n                if fallback_logic_debug:\n                    event[\"EndTimeFallback\"] = item\n                break\n\n        if event_start_time:\n            event['Siemplify_Start_Time'] = event_start_time\n            if fallback_logic_debug and not event.get(\"StartTimeFallback\"):\n                event[\"StartTimeFallback\"] = \"CreatedTimeUTC\"\n        else:\n            event['Siemplify_Start_Time'] = utc_now().isoformat()\n            if fallback_logic_debug:\n                event[\"StartTimeFallback\"] = \"Current time\"\n\n        if event_end_time:\n            event['Siemplify_End_Time'] = event_end_time\n            if fallback_logic_debug and not event.get(\"EndTimeFallback\"):\n                event[\"EndTimeFallback\"] = \"CreatedTimeUTC\"\n        else:\n            event['Siemplify_End_Time'] = utc_now().isoformat()\n            if fallback_logic_debug:\n                event[\"EndTimeFallback\"] = \"Current time\"\n\n    return alert_info\n\n\ndef pass_whitelist_filter(siemplify, alert, whitelist, whitelist_filter_type):\n    # whitelist filter\n    if whitelist:\n        alert_title = \" \".join(alert.properties.title.split()) if alert.properties.title else \"\"\n        alert_title = handle_special_characters(alert_title)\n\n        if whitelist_filter_type == BLACKLIST_FILTER and alert_title in whitelist:\n            siemplify.LOGGER.info(\"Incident with title: \\\"{}\\\" did not pass blacklist filter.\"\n                                  .format(alert.properties.title))\n            return False\n\n        if whitelist_filter_type == WHITELIST_FILTER and alert_title not in whitelist:\n            siemplify.LOGGER.info(\"Incident with title: \\\"{}\\\" did not pass whitelist filter.\"\n                                  .format(alert.properties.title))\n            return False\n\n    return True\n\n\nif __name__ == \"__main__\":\n    is_test_run = not (len(sys.argv) < 2 or sys.argv[1] == 'True')\n    main(is_test_run)\n",
    "documentationLink": "https://integrations.siemplify.co/doc/microsoft-azure-sentinel#microsoft-azure-sentinel-incidents-connector-v2",
    "deviceProductField": "product_type",
    "eventNameField": "event_type",
    "connectorStatus": {
        "connectorIdentifier": "Microsoft Azure Sentinel Incident Connector v2_9cf3ff2b-8655-4343-8f2b-8755ae0bc6d3",
        "connectivityStatus": 1,
        "amountAlertsInLastDay": 0,
        "avgAlertsPerDay": 16
    },
    "isNew": false,
    "agentIdentifier": null
}