{
    "isUpdateAvailable": false,
    "isCustom": false,
    "isEnabled": false,
    "isRemoteConnector": false,
    "environment": "Default Environment",
    "integration": "MicrosoftGraphMail",
    "identifier": "Microsoft Graph Mail Connector_b8463a53-a2e9-4a6f-9862-60dde54438d1",
    "connectorDefinitionName": "Microsoft Graph Mail Connector",
    "displayName": "Microsoft Graph Mail Connector",
    "description": "Connector can be used to fetch emails from the Microsoft Graph Mail service. Connector dynamic list can be used to filter specific values from the email body and subject parts using regexes. By default, regex is used to filter out the urls from the email.",
    "runIntervalInSeconds": 10,
    "resultDataType": 0,
    "version": "1",
    "pythonVersion": 2,
    "isAllowlistSupported": true,
    "params": [
        {
            "connectorIdentifier": null,
            "paramName": "Environment Field Name",
            "paramValue": "",
            "description": "Describes the name of the field where the environment name is stored.\nIf environment field isn't found, environment is \"\"\n",
            "type": 2,
            "mode": 0,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1670907076555,
            "modificationTimeUnixTimeInMs": 1670907076555
        },
        {
            "connectorIdentifier": null,
            "paramName": "Environment Regex Pattern",
            "paramValue": ".*",
            "description": "A regex pattern to run on the value found in the \"Environment Field Name\" field.\nDefault is .* to catch all and return value unchanged.\nUsed to allow the user to manipulate the environment field via regex logic\nIf regex pattern is null or empty, or the environment value is null, the final environment result is \"\"\n",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1670907076555,
            "modificationTimeUnixTimeInMs": 1670907076555
        },
        {
            "connectorIdentifier": null,
            "paramName": "Email exclude pattern",
            "paramValue": "",
            "description": "Regular expression to exclude specific emails from being ingested by the connector. Works with both subject and body part of email. Example is, to exclude mass mailing emails like news from being ingested.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1670907076555,
            "modificationTimeUnixTimeInMs": 1670907076555
        },
        {
            "connectorIdentifier": null,
            "paramName": "Script Timeout (Seconds)",
            "paramValue": "300",
            "description": "Timeout limit for the python process running the current script.",
            "type": 1,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1670907076555,
            "modificationTimeUnixTimeInMs": 1670907076555
        },
        {
            "connectorIdentifier": null,
            "paramName": "Azure AD Endpoint",
            "paramValue": "https://login.microsoftonline.com",
            "description": "Azure AD endpoint to connect to. Can be different for different tenant types.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 1670907076555,
            "modificationTimeUnixTimeInMs": 1670907076555
        },
        {
            "connectorIdentifier": null,
            "paramName": "Microsoft Graph Endpoint",
            "paramValue": "https://graph.microsoft.com",
            "description": "Microsoft Graph endpoint to connect to.  Can be different for different tenant types.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 1670907076555,
            "modificationTimeUnixTimeInMs": 1670907076555
        },
        {
            "connectorIdentifier": null,
            "paramName": "Mail Address",
            "paramValue": "AIMS@nb.com",
            "description": "Mail address to use for connector.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 1670907076555,
            "modificationTimeUnixTimeInMs": 1670907076555
        },
        {
            "connectorIdentifier": null,
            "paramName": "Client ID",
            "paramValue": "b1a8d738-4480-4724-ac6c-ec1695f30350",
            "description": "For Office 365 Oauth authentication, Client (Application) ID of Azure Active Directory App that will be used for the integration.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 1670907076555,
            "modificationTimeUnixTimeInMs": 1670907076555
        },
        {
            "connectorIdentifier": null,
            "paramName": "Client Secret",
            "paramValue": "***************",
            "description": "For Office 365 Oauth authentication, secret can be provided for the auth flow.",
            "type": 3,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 1670907076555,
            "modificationTimeUnixTimeInMs": 1670907076555
        },
        {
            "connectorIdentifier": null,
            "paramName": "Proxy Server Address",
            "paramValue": null,
            "description": "The address of the proxy server to use.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1670907076555,
            "modificationTimeUnixTimeInMs": 1670907076555
        },
        {
            "connectorIdentifier": null,
            "paramName": "Max Emails Per Cycle",
            "paramValue": "10",
            "description": "Fetch X emails per connector cycle",
            "type": 1,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 1670907076555,
            "modificationTimeUnixTimeInMs": 1670907076555
        },
        {
            "connectorIdentifier": null,
            "paramName": "Unread Emails Only",
            "paramValue": "false",
            "description": "If checked, cases will be pulled only from unread emails",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 1670907076555,
            "modificationTimeUnixTimeInMs": 1670907076555
        },
        {
            "connectorIdentifier": null,
            "paramName": "Mark Emails as Read",
            "paramValue": "false",
            "description": "If checked, after the emails have been pulled they will be marked as read.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 1670907076555,
            "modificationTimeUnixTimeInMs": 1670907076555
        },
        {
            "connectorIdentifier": null,
            "paramName": "Disable Overflow",
            "paramValue": "false",
            "description": "If enabled, the connector will ignore the Siemplify overflow mechanism when creating alerts.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1670907076555,
            "modificationTimeUnixTimeInMs": 1670907076555
        },
        {
            "connectorIdentifier": null,
            "paramName": "Original Received Mail Prefix",
            "paramValue": "",
            "description": "Prefix to add to the extracted event keys (to, from,subject,\u2026) from the original email received in the monitored mailbox.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1670907076555,
            "modificationTimeUnixTimeInMs": 1670907076555
        },
        {
            "connectorIdentifier": null,
            "paramName": "Attached Mail File Prefix",
            "paramValue": "",
            "description": "Prefix to add to the extracted event keys (to, from,subject,\u2026) from the attached mail file received with the email in the monitored mailbox.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1670907076555,
            "modificationTimeUnixTimeInMs": 1670907076555
        },
        {
            "connectorIdentifier": null,
            "paramName": "Create a Separate Siemplify Alert per Attached Mail File",
            "paramValue": "false",
            "description": "If enabled, connector will create multiple alerts, 1 alert per attached mail file. This behavior can be useful when processing email with multiple mail files attached and Siemplify event mapping set to create entities from attached mail file.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1670907076555,
            "modificationTimeUnixTimeInMs": 1670907076555
        },
        {
            "connectorIdentifier": null,
            "paramName": "Verify SSL",
            "paramValue": "false",
            "description": "If enabled, verify the SSL certificate for the connection to the Microsoft Graph Mail server is valid.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1670907076555,
            "modificationTimeUnixTimeInMs": 1670907076555
        },
        {
            "connectorIdentifier": null,
            "paramName": "Folder to check for emails",
            "paramValue": "Inbox",
            "description": "Parameter can be used to specify email folder on the mailbox to search for the emails. Parameter is case sensitive",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1670907076555,
            "modificationTimeUnixTimeInMs": 1670907076555
        },
        {
            "connectorIdentifier": null,
            "paramName": "Offset Time In Hours",
            "paramValue": "24",
            "description": "Fetch emails from X hours backwards",
            "type": 1,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 1670907076555,
            "modificationTimeUnixTimeInMs": 1670907076555
        },
        {
            "connectorIdentifier": null,
            "paramName": "Headers to add to events",
            "paramValue": "",
            "description": "Specify what values should be filtered from the \"internetMessageHeaders\" list and what will be added to the Siemplify event. By default, all headers are added, if only specific headers are needed - specify them as a comma separated list by their name, example: \"DKIM-Signature\", \"Received\", \"From\". If no internetHeaders should be added specify a keyword: None",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1670907076555,
            "modificationTimeUnixTimeInMs": 1670907076555
        },
        {
            "connectorIdentifier": null,
            "paramName": "Case Name Template",
            "paramValue": "",
            "description": "When provided, connector will add a new key called \"custom_case_name\" to the Siemplify Event. It can used to have a customer case name. Please refer to the documentation portal for more details. You can provide placeholders in the following format: [name of the field]. Example: Phishing - [event_mailbox]. Note: connector will use first Siemplify Event for placeholders. Only keys that have string value will be handled.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1670907076555,
            "modificationTimeUnixTimeInMs": 1670907076555
        },
        {
            "connectorIdentifier": null,
            "paramName": "Alert Name Template",
            "paramValue": "",
            "description": "If provided, connector will use this value for Siemplify Alert Name. Please refer to the documentation portal for more details. You can provide placeholders in the following format: [name of the field]. Example: Phishing - [event_mailbox]. Note: connector will use first Siemplify Event for placeholders. Only keys that have string value will be handled. If nothing is provided or user provides an invalid template, connector will use the default alert name.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1670907076555,
            "modificationTimeUnixTimeInMs": 1670907076555
        },
        {
            "connectorIdentifier": null,
            "paramName": "Tenant (Directory) ID",
            "paramValue": "3f06a216-e798-47d3-9b06-31482aa5a648",
            "description": "For Office 365 Oauth authentication, Azure Tenant (Directory) ID.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 1670907076555,
            "modificationTimeUnixTimeInMs": 1670907076555
        },
        {
            "connectorIdentifier": null,
            "paramName": "Proxy Username",
            "paramValue": "",
            "description": "The proxy username to authenticate with.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1670907076555,
            "modificationTimeUnixTimeInMs": 1670907076555
        },
        {
            "connectorIdentifier": null,
            "paramName": "Proxy Password",
            "paramValue": "",
            "description": "The proxy password to authenticate with.",
            "type": 3,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 1670907076555,
            "modificationTimeUnixTimeInMs": 1670907076555
        }
    ],
    "allowList": [],
    "integrationVersion": 2.0,
    "isScriptConnector": true,
    "script": "import os\nimport re\nimport sys\nimport uuid\nfrom typing import List, Dict\n\nfrom EnvironmentCommon import GetEnvironmentCommonFactory\nfrom TIPCommon import (\n    is_overflowed,\n    extract_connector_param,\n    get_last_success_time,\n    read_ids,\n    write_ids,\n    save_timestamp,\n    convert_datetime_to_unix_time,\n    is_approaching_timeout,\n    unix_now,\n    TIMEOUT_THRESHOLD\n)\n\nfrom EmailUtils import get_html_urls, EmailUtils\nfrom MicrosoftGraphMailManager import MicrosoftGraphMailManager\nfrom SiemplifyConnectors import SiemplifyConnectorExecution\nfrom SiemplifyConnectorsDataModel import CaseInfo\nfrom SiemplifyUtils import output_handler\nfrom constants import (\n    CASE_NAME_PATTERN,\n    DEFAULT_DIVIDER,\n    PRIORITY_DEFAULT,\n    STORED_IDS_LIMIT,\n    KEYS_TO_EXCEPT_ON_TRANSFORMATION,\n)\nfrom datamodels import MicrosoftGraphEmail\nfrom exceptions import InvalidParameterException\nfrom utils import (\n    transform_dict_keys,\n    transform_template_string,\n    create_siemplify_case_wall_attachment_object,\n)\n\n# =====================================\n#              CONSTANTS              #\n# =====================================\nCONNECTOR_NAME = \"Microsoft Graph Mail Connector\"\nCONNECTOR_STARTING_TIME = unix_now()\n\n\nclass GraphToSiemplifyService:\n    def __init__(self, siemplify, environment_common, alert_per_attachment: bool, case_name_template: str,\n                 alert_name_template: str, headers_to_add_to_events: List[str]):\n        self.siemplify = siemplify\n        self.environment_common = environment_common\n        self.alert_per_attachment = alert_per_attachment\n        self.case_name_template = case_name_template\n        self.alert_name_template = alert_name_template\n        self.headers_to_add_to_events = headers_to_add_to_events\n        self.regex_map = self.build_regex_map(self.siemplify.whitelist)\n        self.email_utils = EmailUtils()\n\n    def build_regex_map(self, regex_list):\n        regex_map = {}\n        for regex_item in regex_list:\n            try:\n                if ': ' in regex_item:\n                    # Split only once by ':'\n                    user_regex = regex_item.split(': ', 1)\n                    # check if user regex include key (regex name) and value (the regex itself)\n                    if len(user_regex) >= 2:\n                        regex_map.update({user_regex[0]: user_regex[1]})\n            except Exception as e:\n                self.siemplify.logger.error(\n                    \"Unable to get parse whitelist item {}. Ignoring item and continuing.\".format(\n                        regex_item))\n                self.siemplify.logger.exception(e)\n        return regex_map\n\n    def extract_regex_from_content(self, content):\n        \"\"\"\n        Get urls, subject, from and to addresses from email body\n        :param content: {str} email body\n        :return: {dict} fields after parse.\n        \"\"\"\n        result_dictionary = {}\n        regex_value = self.regex_map.get(\"urls\")\n        if regex_value:\n            regex_object = re.compile(regex_value)\n            all_results = regex_object.findall(content)\n\n            for index, result in enumerate(all_results, 1):\n                # Divide keys\n                key_name = f'url_{index}'\n                result_dictionary[key_name] = result\n\n        return result_dictionary\n\n    def get_eml_attachments(self, email: MicrosoftGraphEmail):\n        \"\"\"\n        Get eml attachments.\n        :param email: {MicrosoftGraphEmail} Parse microsoft graph email\n        :return: {list} EML attachments list exported from original message\n        \"\"\"\n        attachments = []\n\n        for eml_attachment in email.eml_attachments:\n            try:\n                self.siemplify.LOGGER.info(\"Parsing EML: {}\".format(eml_attachment.name))\n                parsed_eml = self.email_utils.convert_siemplify_eml_to_connector_eml(\n                    eml_attachment.content, headers_to_add=self.headers_to_add_to_events)\n                parsed_eml[\"attachments_md5_filehash\"] = eml_attachment.md5_hash()\n\n                attachments.append((eml_attachment.name, parsed_eml))\n\n            except Exception as err:\n                self.siemplify.LOGGER.error(\"Failed Parsing EML content\")\n                self.siemplify.LOGGER.exception(err)\n        return attachments\n\n    def get_msg_attachments(self, email: MicrosoftGraphEmail):\n        \"\"\"\n        Get msg attachments.\n        :param email: {MicrosoftGraphEmail} Parse microsoft graph email\n        :return: {list} MSG attachments list exported from original message\n        \"\"\"\n        parsed_attachments = []\n        for msg_attachment in email.msg_attachments:\n            try:\n                self.siemplify.LOGGER.info(\"Parsing MSG: {}\".format(msg_attachment.name))\n                parsed_msg = self.email_utils.convert_siemplify_msg_to_connector_msg(\n                    msg_attachment.content)\n                parsed_msg[\"attachments_md5_filehash\"] = msg_attachment.md5_hash()\n\n                parsed_attachments.append((msg_attachment.name, parsed_msg))\n\n            except Exception as err:\n                self.siemplify.LOGGER.error(\"Failed Parsing MSG content\")\n                self.siemplify.LOGGER.exception(err)\n\n        return parsed_attachments\n\n    def get_ics_attachments(self, email: MicrosoftGraphEmail):\n        \"\"\"\n        Get ics attachments.\n        :param email: {MicrosoftGraphEmail} Parse microsoft graph email\n        :return: {email} ICS attachments list exported from original message\n        \"\"\"\n        parsed_attachments_data = []\n        for ics_attachment in email.ics_attachments:\n            try:\n                self.siemplify.LOGGER.info(\"Parsing ICS: {}\".format(ics_attachment.name))\n                parsed_ics_list = self.email_utils.convert_siemplify_ics_to_connector_msg(\n                    ics_attachment.content)\n\n                if len(parsed_ics_list) > 1:\n                    file_name, file_extension = os.path.splitext(ics_attachment.name)\n                    for index, ics in enumerate(parsed_ics_list, 1):\n                        new_file_name = \"{}_{}{}\".format(file_name, index, file_extension)\n                        parsed_attachments_data.append((new_file_name, ics))\n                elif len(parsed_ics_list) == 1:\n                    parsed_attachments_data.append((ics_attachment.name, parsed_ics_list[0]))\n\n            except Exception as err:\n                self.siemplify.LOGGER.error(\"Failed Parsing ICS content\")\n                self.siemplify.LOGGER.exception(err)\n\n        return parsed_attachments_data\n\n    def attach_file_to_case(self, file_name, file_content):\n        self.siemplify.LOGGER.info(\"Checking EML and MSG attachments to attach to the case\")\n\n        try:\n            if isinstance(file_content, str):\n                file_content = file_content.encode()\n            self.siemplify.LOGGER.info(\"Attached {} file to the case\".format(file_name))\n            return create_siemplify_case_wall_attachment_object(file_name, file_content)\n        except Exception as e:\n            self.siemplify.LOGGER.error(\"Failed to attach {} to the case wall\".format(file_name))\n            self.siemplify.LOGGER.exception(e)\n\n    def process_alert(self, alert: MicrosoftGraphEmail, attached_mail_prefix: str, original_mail_prefix: str):\n        if not self.alert_per_attachment:\n            return [self.create_case(alert, attached_mail_prefix, original_mail_prefix), ]\n        return self.create_cases(alert, attached_mail_prefix, original_mail_prefix)\n\n    def get_item_attachments_data(self, email):\n        \"\"\"\n        Get attachments from message.\n        :param email: {MicrosoftGraphEmail} If True will load only unread emails.\n        :return: {list} Item attachments list exported from original message\n        \"\"\"\n        eml_attachments = self.get_eml_attachments(email)\n        msg_attachments = self.get_msg_attachments(email)\n        ics_attachments = self.get_ics_attachments(email)\n\n        self.siemplify.LOGGER.info(\n            'Found {0} EMLs, {1} MSGs and {2} ICSs for mail with ID: {3}'.format(\n                len(eml_attachments),\n                len(msg_attachments),\n                len(ics_attachments),\n                email.id))\n\n        return eml_attachments + msg_attachments + ics_attachments\n\n    def get_events_for_attachments(self, alert: MicrosoftGraphEmail, prefix=None):\n        \"\"\"\n        Create and return evens from original message attachments only EML/MSG/ICS.\n        :param alert: {MicrosoftGraphEmail} Parsed EML content.\n        :param prefix: {str} Prefix for events keys\n        :return: list , list events: Events list created from attachments, file_names:\n        list of file names only EML/MSG/ICS\n        \"\"\"\n        events = []\n        attachments = self.get_item_attachments_data(alert)\n        for index, value in enumerate(attachments):\n            parsed_email_filename, parsed_email = value\n            self.siemplify.LOGGER.info(\"Processing parsed email: {}\".format(parsed_email_filename))\n            additional_info = self.extract_regex_from_content(parsed_email)\n\n            urls, original_src_urls = get_html_urls(parsed_email.get(\"html_body\", \"\"))\n            additional_info.update({\"urls_from_html_part\": original_src_urls})\n            additional_info.update({\"visible_urls_from_html_part\": urls})\n\n            event_data = alert.create_event(\n                additional_info=additional_info,\n                attachment_data=parsed_email,\n            )\n            event_data = transform_dict_keys(\n                original_dict=event_data,\n                prefix=prefix,\n                suffix=index,\n                keys_to_except=KEYS_TO_EXCEPT_ON_TRANSFORMATION\n            )\n\n            events.append(event_data)\n        return events\n\n    def create_case(self, alert: MicrosoftGraphEmail, attached_mail_prefix, original_mail_prefix):\n        attachment_events = self.get_events_for_attachments(alert, attached_mail_prefix)\n        case_info = self.generate_case_info(alert=alert, mail_prefix=original_mail_prefix)\n        case_info.events.extend(attachment_events)\n        return case_info\n\n    def create_cases(self, alert, attached_mail_prefix, original_mail_prefix):\n        case_info = self.generate_case_info(alert=alert, mail_prefix=original_mail_prefix)\n        cases = [case_info, ]\n        item_attachments = self.get_item_attachments_data(alert)\n        for attachment_name, attachment_data in item_attachments:\n            attachment_case = self.generate_case_info(\n                alert=alert,\n                mail_prefix=attached_mail_prefix,\n                attachment_data=attachment_data,\n            )\n            attachment_case.events.append(case_info.events[0])\n            cases.append(attachment_case)\n        return cases\n\n    def generate_case_info(self, alert: MicrosoftGraphEmail, mail_prefix, attachment_data: Dict = None):\n        additional_info = self.extract_regex_from_content(alert.body_content)\n        urls, original_src_urls = get_html_urls(alert.body_content)\n        additional_info.update({\"urls_from_html_part\": original_src_urls})\n        additional_info.update({\"visible_urls_from_html_part\": urls})\n\n        event_details = alert.create_event(additional_info=additional_info,\n                                           attachment_data=attachment_data,\n                                           headers_to_add_to_events=self.headers_to_add_to_events)\n        self.siemplify.LOGGER.info(\"Event dict created.\")\n\n        # Construct case name if case name template provided\n        case_name = transform_template_string(self.case_name_template, event_details)\\\n            if self.case_name_template else \"\"\n        # Construct alert name if alert name template provided\n        alert_name = transform_template_string(self.alert_name_template, event_details)\\\n            if self.alert_name_template else \"\"\n\n        event_details = transform_dict_keys(\n            original_dict=event_details,\n            prefix=mail_prefix,\n            keys_to_except=KEYS_TO_EXCEPT_ON_TRANSFORMATION\n        )\n\n        if case_name:\n            event_details[\"custom_case_name\"] = case_name\n\n        # Create case info object\n        case_info = CaseInfo()\n        case_info.name = alert_name or CASE_NAME_PATTERN.format(alert.mailbox_name)\n        case_info.rule_generator = case_info.name\n        case_info.start_time = convert_datetime_to_unix_time(alert.parsed_time)\n        case_info.end_time = convert_datetime_to_unix_time(alert.parsed_time)\n        case_info.identifier = alert.internet_message_id\n        case_info.ticket_id = case_info.identifier\n        case_info.display_id = alert.id if attachment_data is None else str(uuid.uuid4())\n        case_info.priority = PRIORITY_DEFAULT\n        case_info.device_vendor = event_details[\"device_vendor\"]\n        case_info.device_product = event_details[\"device_product\"]\n        case_info.attachments = []\n\n        if attachment_data is None:\n            # append attachments to case wall\n            for attachment in alert.file_attachments:\n                attachment_for_case = self.attach_file_to_case(attachment.name, attachment.content)\n                if attachment_for_case:\n                    case_info.attachments.append(attachment_for_case)\n\n        case_info.environment = self.environment_common.get_environment(event_details)\n        case_info.events = [event_details]\n\n        return case_info\n\n\n@output_handler\ndef main(test_run):\n    cases = []\n    connector_scope = SiemplifyConnectorExecution()\n    connector_scope.script_name = CONNECTOR_NAME\n\n    if test_run:\n        connector_scope.LOGGER.info(\"***** This is an \\\"IDE Play Button\\\"\\\\\\\"Run Connector once\\\" test run ******\")\n\n    connector_scope.LOGGER.info(\"-------------------- Main - Param Init --------------------\")\n\n    environment_field_name = extract_connector_param(\n        connector_scope,\n        param_name=\"Environment Field Name\"\n    )\n    environment_regex = extract_connector_param(\n        connector_scope,\n        param_name='Environment Regex Pattern'\n    )\n    script_timeout = extract_connector_param(\n        connector_scope,\n        param_name=\"PythonProcessTimeout\",\n        is_mandatory=True,\n        input_type=int,\n        print_value=True\n    )\n\n    # Account and connection\n    azure_ad_endpoint = extract_connector_param(\n        connector_scope,\n        param_name='Azure AD Endpoint',\n        is_mandatory=True\n    )\n    microsoft_graph_endpoint = extract_connector_param(\n        connector_scope,\n        param_name='Microsoft Graph Endpoint',\n        is_mandatory=True\n    )\n    mail_address = extract_connector_param(\n        connector_scope,\n        param_name=\"Mail Address\",\n        is_mandatory=True\n    )\n    client_id = extract_connector_param(\n        connector_scope,\n        param_name='Client ID',\n        input_type=str,\n        is_mandatory=True,\n    )\n    client_secret = extract_connector_param(\n        connector_scope,\n        param_name='Client Secret',\n        input_type=str,\n        is_mandatory=True,\n        remove_whitespaces=False\n    )\n    tenant = extract_connector_param(\n        connector_scope,\n        param_name='Tenant (Directory) ID',\n        input_type=str,\n        is_mandatory=True,\n    )\n    verify_ssl = extract_connector_param(\n        connector_scope,\n        param_name=\"Verify SSL\",\n        input_type=bool,\n        is_mandatory=True\n    )\n\n    # Flow control for fetching\n    folder_name = extract_connector_param(\n        connector_scope,\n        param_name=\"Folder to check for emails\",\n        is_mandatory=True\n    )\n    email_exclude_pattern = extract_connector_param(\n        connector_scope,\n        param_name='Email exclude pattern'\n    )\n    offset_time_in_hours = extract_connector_param(\n        connector_scope,\n        param_name=\"Offset Time In Hours\",\n        input_type=int,\n        is_mandatory=True\n    )\n    max_email_per_cycle = extract_connector_param(\n        connector_scope,\n        param_name=\"Max Emails Per Cycle\",\n        input_type=int,\n        is_mandatory=True\n    )\n    unread_only = extract_connector_param(\n        connector_scope,\n        param_name=\"Unread Emails Only\",\n        input_type=bool\n    )\n    disable_overflow = extract_connector_param(\n        siemplify=connector_scope,\n        param_name=\"Disable Overflow\",\n        input_type=bool\n    )\n\n    # Processing params\n    mark_as_read = extract_connector_param(\n        connector_scope,\n        param_name=\"Mark Emails as Read\",\n        input_type=bool\n    )\n    original_mail_prefix = extract_connector_param(\n        connector_scope,\n        param_name=\"Original Received Mail Prefix\"\n    )\n    attached_mail_prefix = extract_connector_param(\n        connector_scope,\n        param_name=\"Attached Mail File Prefix\"\n    )\n    alert_per_attachment = extract_connector_param(\n        connector_scope,\n        param_name=\"Create a Separate Siemplify Alert per Attached Mail File\",\n        input_type=bool\n    )\n    headers_to_add_to_events = extract_connector_param(\n        connector_scope,\n        param_name='Headers to add to events'\n    )\n    case_name_template = extract_connector_param(\n        connector_scope,\n        param_name=\"Case Name Template\"\n    )\n    alert_name_template = extract_connector_param(\n        connector_scope,\n        param_name=\"Alert Name Template\"\n    )\n\n    # Parameters parsing and transformation\n    headers_to_add_to_events = list(filter(\n        lambda x: bool(x),\n        map(lambda x: x.strip(),\n            headers_to_add_to_events.split(DEFAULT_DIVIDER))\n    )) if headers_to_add_to_events else []\n\n    connector_scope.LOGGER.info(\"------------------- Main - Started -------------------\")\n\n    try:\n        if original_mail_prefix and \" \" in original_mail_prefix:\n            raise InvalidParameterException(\"Original Received Mail Prefix configured contains a space, which is not \"\n                                            \"supported, please remove any spaces and try again.\")\n\n        if attached_mail_prefix and \" \" in attached_mail_prefix:\n            raise InvalidParameterException(\"Attached Mail File Prefix configured contains a space, which is not \"\n                                            \"supported, please remove any spaces and try again.\")\n\n        if offset_time_in_hours < 0:\n            raise InvalidParameterException(f\"\\\"Offset Time In Hours\\\" must be non-negative\")\n\n        # Read already existing email ids\n        existing_ids = read_ids(connector_scope)\n        connector_scope.LOGGER.info(f\"Successfully loaded {len(existing_ids)} existing ids\")\n        last_success_time = get_last_success_time(connector_scope, offset_with_metric={'hours': offset_time_in_hours})\n        environment_common = GetEnvironmentCommonFactory.create_environment_manager(\n            siemplify=connector_scope,\n            environment_field_name=environment_field_name,\n            environment_regex_pattern=environment_regex\n        )\n\n        connector_scope.LOGGER.info(\"Connecting to Microsoft Graph Mail.\")\n        email_client = MicrosoftGraphMailManager(\n            azure_ad_endpoint=azure_ad_endpoint,\n            microsoft_graph_endpoint=microsoft_graph_endpoint,\n            client_id=client_id,\n            client_secret=client_secret,\n            tenant=tenant,\n            siemplify=connector_scope,\n            mail_address=mail_address,\n            verify_ssl=verify_ssl\n        )\n\n        emails_from_api = email_client.get_emails(\n            folder_name=folder_name,\n            datetime_from=last_success_time,\n            max_email_per_cycle=max_email_per_cycle,\n            existing_ids=existing_ids,\n            unread_only=unread_only,\n            email_exclude_pattern=email_exclude_pattern,\n            connector_starting_time=CONNECTOR_STARTING_TIME,\n            script_timeout=script_timeout\n        )\n\n        if test_run:\n            emails_from_api = emails_from_api[:1]\n            connector_scope.LOGGER.info(\"Trimmed number of emails for processing to 1, since it's a test run\")\n\n        processed_emails = []\n\n        for email in emails_from_api:\n            if is_approaching_timeout(script_timeout, CONNECTOR_STARTING_TIME, TIMEOUT_THRESHOLD):\n                connector_scope.LOGGER.info('Timeout is approaching. Connector will gracefully exit')\n                break\n\n            connector_scope.LOGGER.info(f\"Starting processing of {email.id}\")\n\n            graph_to_siemplify_service = GraphToSiemplifyService(\n                siemplify=connector_scope,\n                environment_common=environment_common,\n                alert_per_attachment=alert_per_attachment,\n                case_name_template=case_name_template,\n                alert_name_template=alert_name_template,\n                headers_to_add_to_events=headers_to_add_to_events\n            )\n            new_cases = graph_to_siemplify_service.process_alert(\n                alert=email,\n                attached_mail_prefix=attached_mail_prefix,\n                original_mail_prefix=original_mail_prefix\n            )\n            original_case = new_cases[0]\n\n            alert_is_overflowed = (\n                not disable_overflow and\n                is_overflowed(connector_scope, original_case, test_run)\n            )\n            if alert_is_overflowed:\n                connector_scope.LOGGER.info(\n                    f'{original_case.rule_generator}-{original_case.ticket_id}-'\n                    f'{original_case.environment}-{original_case.device_product}'\n                    f' found as overflow alert. Skipping.'\n                )\n                continue\n\n            cases.extend(new_cases)\n            processed_emails.append(email)\n            existing_ids.append(email.id)\n\n        if mark_as_read and not test_run:\n            email_client.mark_emails_as_read(processed_emails)\n\n        if not test_run and processed_emails:\n            connector_scope.LOGGER.info(\"Saving existing ids.\")\n            write_ids(connector_scope, existing_ids, stored_ids_limit=STORED_IDS_LIMIT)\n            save_timestamp(\n                siemplify=connector_scope,\n                alerts=processed_emails,\n                timestamp_key=\"timestamp\"\n            )\n\n        connector_scope.LOGGER.info(\"Created {} cases.\".format(len(cases)))\n\n    except InvalidParameterException as error:\n        connector_scope.LOGGER.error(error)\n        if test_run:\n            raise error\n\n        raise\n\n    except Exception as error:\n        connector_scope.LOGGER.error(\"Error in main handler\")\n        connector_scope.LOGGER.exception(error)\n        if test_run:\n            raise error\n\n        raise\n\n    connector_scope.LOGGER.info(\"------------------- Main - Finished -------------------\")\n    connector_scope.return_package(cases)\n\n\nif __name__ == \"__main__\":\n    # Connectors are run in iterations. The interval is configurable from the ConnectorsScreen UI.\n    is_test = not (len(sys.argv) < 2 or sys.argv[1] == 'True')\n    main(is_test)\n",
    "documentationLink": "https://integrations.siemplify.co/doc/microsoft-graph-mail#microsoft-graph-mail-connector",
    "deviceProductField": "device_product",
    "eventNameField": "event_name",
    "connectorStatus": null,
    "isNew": false,
    "agentIdentifier": null
}