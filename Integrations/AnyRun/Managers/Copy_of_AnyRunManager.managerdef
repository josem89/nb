{
    "id": 0,
    "type": 4,
    "name": "Copy_of_AnyRunManager",
    "description": null,
    "script": "import requests\nfrom urllib.parse import urljoin\nimport json\nimport copy\nfrom SiemplifyDataModel import EntityTypes\nfrom AnyRunParser import AnyRunParser\nfrom AnyRunExceptions import (\n    AnyRunError\n)\nfrom AnyRunParser import AnyRunParser\nimport time\nfrom constants import (\n    PING_QUERY,\n    ANY_RUN_API_URL,\n    ANALYSIS_QUERY,\n    ANALYSIS_URL_TASK,\n    URL_ELEMENT,\n    FILEURL_ELEMENT,\n    FILE_ELEMENT,\n    ENDPOINTS,\n    DEFAULT_SKIP_NUMBER,\n    SLEEP_TIME\n\n)\n\nclass AnyRunManager(object):\n    def __init__(self, api_key=None, siemplify_logger=None):\n        \"\"\"\n        The method is used to init an object of Manager class\n        :param api_key: API Key of the Any.Run instance.\n        :param siemplify_logger: Siemplify logger.\n        \"\"\"\n        \n        self.api_key = api_key\n        self.api_root = ANY_RUN_API_URL\n        self.siemplify_logger = siemplify_logger\n        self.session = requests.session()\n        self.parser = AnyRunParser()\n        self.session.headers = {\"Authorization\": \"API-Key {}\".format(api_key)}\n        self.parser = AnyRunParser()\n\n    @staticmethod\n    def validate_response(response, error_msg=\"An error occurred\"):\n        try:\n            response.raise_for_status()\n\n        except requests.HTTPError as error:\n            try:\n                response.json()\n            except:\n                # Not a JSON - return content\n                raise AnyRunError(\n                    \"{error_msg}: {error} - {text}\".format(\n                        error_msg=error_msg,\n                        error=error,\n                        text=error.response.content)\n                )\n\n            raise AnyRunError(\n                \"{error_msg}: {error} {text}\".format(\n                    error_msg=error_msg,\n                    error=response.json().get('name'),\n                    text=json.dumps(response.json()))\n            )\n\n    def _get_full_url(self, url_id, **kwargs):\n        \"\"\"\n        Get full url from url identifier.\n        :param url_id: {str} The id of url\n        :param kwargs: {dict} Variables passed for string formatting\n        :return: {str} The full url\n        \"\"\"\n        return urljoin(self.api_root, ENDPOINTS[url_id].format(**kwargs))\n\n    def test_connectivity(self):\n        \"\"\"\n        Test integration connectivity.\n        :return: {bool}\n        \"\"\"\n\n        request_url = \"{}{}\".format(self.api_root, PING_QUERY)\n        result = self.session.get(request_url)\n        # Verify result.\n        self.validate_response(result)\n\n        return False\n\n    def analyze(self,element_type, active_session, element_for_analysis, os_version ,operation_system_bitness, os_env_type,network_connection_status,fakenet_feature_status, use_tor, opt_network_mitm, opt_network_geo, opt_network_heavyevasion,opt_privacy_type, obj_ext_startfolder,opt_timeout):\n        \"\"\"\n        Function that analyzes URLS and Files\n        :param active_session{int} How many seconds to wait for the available session\n        :param fakenet_feature_status{bool} Whether or now the FakeNet should be used\n        :param element_for_analysis{string} URL which should be analyzed\n        :param os_env_type{string} Environment Type \n        :param os_version{string} Windows OS Version\n        :param operation_system_bitness{string} Operation System Bitness\n        :param use_tor{bool} Whether or now the Tor should be used\n        :param network_connection_status{bool} Whether or now the Network connection status should be used\n        :param opt_network_geo {string} Which GEO Location to use\n        :param opt_network_mitm {bool} Whether or now the MITM should be used\n        :param opt_network_heavyevasion{bool} Whether or now the HeavyEvasion should be used\n        :param opt_privacy_type {string}  Privacy Type\n        :param opt_timeout {int} Timeout in seconds\n        :param obj_ext_startfolder {string} Type of the startfolder\n        :return Response\n        \"\"\"\n\n        files=None\n        if element_type == URL_ELEMENT:\n            payload = {\n                \"obj_type\":\"url\",\n                \"obj_url\":element_for_analysis,\n                \"env_bitness\": operation_system_bitness,\n                \"env_version\": os_version,\n                \"opt_network_fakenet\":fakenet_feature_status,\n                \"env_type\":os_env_type,\n                \"opt_network_connect\":network_connection_status,\n                \"opt_network_tor\":use_tor,\n                \"opt_network_mitm\": opt_network_mitm,\n                \"opt_network_geo\":opt_network_geo,\n                \"opt_network_heavyevasion\":False,\n                \"opt_privacy_type\":opt_privacy_type,\n                \"opt_timeout\":opt_timeout,\n                \"obj_ext_startfolder\":obj_ext_startfolder   \n            }\n            \n        if element_type == FILE_ELEMENT:\n            files = [\n                ('file', open(element_for_analysis,'rb'))\n            ]\n            payload = {\n                \"env_bitness\": operation_system_bitness,\n                \"env_version\": os_version,\n                \"opt_network_fakenet\":fakenet_feature_status,\n                \"env_type\":os_env_type,\n                \"opt_network_connect\":network_connection_status,\n                \"opt_network_tor\":use_tor,\n                \"opt_network_mitm\": opt_network_mitm,\n                \"opt_network_geo\":opt_network_geo,\n                \"opt_privacy_type\":opt_privacy_type,\n                \"opt_timeout\":opt_timeout,\n                \"obj_ext_startfolder\":obj_ext_startfolder   \n            }\n            \n        if element_type == FILEURL_ELEMENT:\n            payload = {\n                \"obj_type\":\"download\",\n                \"obj_url\":element_for_analysis,\n                \"env_bitness\": operation_system_bitness,\n                \"env_version\": os_version,\n                \"opt_network_fakenet\":fakenet_feature_status,\n                \"env_type\":os_env_type,\n                \"opt_network_connect\":network_connection_status,\n                \"opt_network_tor\":use_tor,\n                \"opt_network_mitm\": opt_network_mitm,\n                \"opt_network_geo\":opt_network_geo,\n                \"opt_network_heavyevasion\":opt_network_heavyevasion,\n                \"opt_privacy_type\":opt_privacy_type,\n                \"opt_timeout\":opt_timeout,\n                \"obj_ext_startfolder\":obj_ext_startfolder   \n            }\n            \n\n        request_url = \"{}{}\".format(self.api_root, ANALYSIS_QUERY)\n\n        counter = 0\n        counter_max = active_session\n        can_send_request = False\n        while not can_send_request:\n\n            if counter == counter_max:\n                raise AnyRunError(\"Action reached timeout waiting for report.\")\n   \n            can_send_request = self.check_available_sessions()  \n            if can_send_request:\n                response = self.session.post(request_url, data=payload, files=files)\n                self.validate_response(response)\n                return self.parser.build_task_object(response.json())\n               \n            counter = counter + 1 \n            time.sleep(SLEEP_TIME)    \n        \n    \n    def fetch_report(self, task_id):\n        \"\"\"\n        :param task_id {string} ID of the task for which report should be fetched\n        :return URLReport Object\n        \"\"\"        \n        \n        request_url = \"{}{}\".format(self.api_root, ANALYSIS_URL_TASK.format(task_id))\n        \n        response = self.session.get(request_url)\n        self.validate_response(response)\n        \n        return self.parser.build_url_report_object(response.json())\n        \n    def get_analysis_history(self, limit, team_history=False, skip=DEFAULT_SKIP_NUMBER):\n        \"\"\"\n        Get recent analysis history\n        :param limit: {int} Number of recent items to fetch\n        :param team_history: {bool} Whether to get  team history or not\n        :param skip: {int} Number of first scans to skip.\n        :return: {list} List of History Item objects\n        \"\"\"\n        request_url = self._get_full_url('analysis_history')\n        payload = {\n            \"team\": json.dumps(team_history),\n            \"skip\": skip,\n            \"limit\": limit\n        }\n        response = self.session.get(request_url, params=payload)\n        self.validate_response(response)\n        return self.parser.build_history_items_list(response.json())\n\n    def get_report(self, uuid):\n        \"\"\"\n        Get report with uuid\n        :param uuid: {str} Report uuid\n        :return: Report object\n        \"\"\"\n        request_url = self._get_full_url('get_report', uuid=uuid)\n        response = self.session.get(request_url)\n        self.validate_response(response)\n        return self.parser.build_report_object(response.json())\n\n\n    def check_available_sessions(self):\n        \"\"\"\n        Method that checks if there are available sessions for the user\n        :param Availability{bool} True if there are available sessions, False if not\n        \"\"\"\n\n        request_url = \"{}{}\".format(self.api_root, PING_QUERY)\n        result = self.session.get(request_url)\n        self.validate_response(result)\n        \n        availability = result.json().get(\"data\",{}).get(\"limits\",{}).get(\"parallels\",{}).get(\"available\")\n        \n        if availability == 0:\n            return False\n\n        return True\n",
    "integration": "AnyRun",
    "creator": "7a7f9e2c-7774-4221-8558-986f5708fd17",
    "creatorFullName": "jose marin",
    "isEnabled": true,
    "isCustom": true,
    "version": 4,
    "parameters": [],
    "connectorRules": null,
    "isConnectorRulesSupported": false,
    "documentationLink": null,
    "pythonVersion": "V3_7"
}