{
    "id": 0,
    "type": 4,
    "name": "ExtendedMicrosoftAzureSentinelManager",
    "description": null,
    "script": "import json\nimport uuid\nimport isodate\nimport requests\nfrom datetime import datetime, timedelta\nfrom MicrosoftAzureSentinelParser import MicrosoftAzureSentinelParser\nfrom MicrosoftAzureSentinelCommon import (\n    MicrosoftAzureSentinelCommon,\n    read_backlog_ids,\n    validate_backlog\n)\nfrom SiemplifyUtils import convert_string_to_datetime\nfrom datamodels import TagCollection, CustomHuntingRuleRequest\nfrom exceptions import (\n    MicrosoftAzureSentinelManagerError,\n    MicrosoftAzureSentinelValidationError,\n    MicrosoftAzureSentinelPermissionError,\n    MicrosoftAzureSentinelUnauthorizedError,\n    MicrosoftAzureSentinelBadRequestError,\n    MicrosoftAzureSentinelNotFoundError,\n    MicrosoftAzureSentinelTimeoutError,\n    MicrosoftAzureSentinelConflictError,\n)\nfrom urllib.parse import urljoin\nfrom utils import convert_list_to_comma_separated_string, LOGGER\nfrom enum import Enum\nfrom AzureQueryBuilder import QueryBuilder, Condition, QueryOperatorEnum, OperatorEnum\nfrom constants import ALERT_TYPES_WITH_EVENTS\n\n\nHEADERS = {\n    \"Content-Type\": \"application/json\"\n}\n# @TODO remove after refactor\nDEFAULT_API_VERSION = '2019-01-01-preview'\n\nLOGIN_ENDPOINT = \"/{}/oauth2/token\"\nTIME_FORMAT = \"%Y-%m-%dT%H:%M:%S.%fZ\"\nMIN_PT_DURATION = timedelta(minutes=5)\nMAX_PT_DURATION = timedelta(days=14)\n\n\nAPI_ENDPOINTS = {\n    'base_url': {\n       'url': '{api_root}/subscriptions/{subscriptions}/resourcegroups/{resource}'\n             '/providers/microsoft.operationalinsights/workspaces/{workspace}/'\n    },\n    'incidents': {\n        'url': 'providers/Microsoft.SecurityInsights/incidents',\n        'version': '2019-01-01-preview'\n    },\n    'incident_comments': {\n        'url': 'providers/Microsoft.SecurityInsights/incidents/{}/comments',\n        'version': '2022-07-01-preview'\n    },\n    'incident': {\n        'url': 'providers/Microsoft.SecurityInsights/Incidents/{incident_name}',\n        'version': '2019-01-01-preview'\n    },\n    'incident_comment': {\n        'url': 'providers/Microsoft.SecurityInsights/Incidents/{incident_number}/comments/{incident_comment_id}',\n        'version': '2019-01-01-preview'\n    },\n    'incident_cases': {\n        'url': 'providers/Microsoft.SecurityInsights/Cases',\n        'version': '2019-01-01-preview'\n    },\n    'INCIDENT_AGGREGATION': {\n        'URL': 'providers/Microsoft.SecurityInsights/aggregations/Cases',\n        'VERSION': '2019-01-01-preview'\n    },\n    'custom_hunting_rules_listing': {\n        'url': 'savedSearches',\n        'version': '2015-03-20'\n    },\n    'custom_hunting_rules': {\n        'url': 'savedSearches/{custom_hunting_rule_id}',\n        'version': '2015-03-20'\n    },\n    'alert_rules_listing': {\n        'url': 'providers/Microsoft.SecurityInsights/alertRules',\n        'version': '2019-01-01-preview'\n    },\n    'alert_rules': {\n        'url': 'providers/Microsoft.SecurityInsights/alertRules/{alert_rule_id}',\n        'version': '2019-01-01-preview'\n    },\n    'kql_query': {\n        'url': 'query',\n        'version': '2017-10-01',\n    },\n    'incident_aggregation': {\n        'url': 'providers/Microsoft.SecurityInsights/aggregations/Cases',\n        'version': '2019-01-01-preview'\n    },\n    'ping': {\n        'url': 'providers/Microsoft.SecurityInsights/incidents',\n        'version': '2019-01-01-preview'\n    },\n    'GET_INCIDENT_ALERTS': {\n        'URL': 'providers/Microsoft.SecurityInsights/incidents/{incident_name}/alerts',\n        'VERSION': '2019-01-01-preview'\n    },\n    'GET_ALERT_ENTITIES': {\n        'URL': 'providers/Microsoft.SecurityInsights/entities/{alert_id}/expand',\n        'VERSION': '2019-01-01-preview',\n        'DEFAULT_EXPANSION_ID': '98b974fd-cc64-48b8-9bd0-3a209f5b944b'\n    },\n    'GET_INCIDENT_ENTITIES': {\n        'URL': 'providers/Microsoft.SecurityInsights/Incidents/{incident_id}/entities',\n        'VERSION': '2019-01-01-preview'\n    }\n}\n\nADDITIONAL_DEFAULT_FOR_VALIDATION = ['Not Updated']\nCLOSED = 'Closed'\n\nDEFAULT_SEVERITIES = [\n    'Informational',\n    'Low',\n    'Medium',\n    'High',\n]\n\nDEFAULT_ALERT_RULE_SEVERITIES = [\n    'Informational',\n    'Low',\n    'Medium',\n    'High',\n]\n\nDEFAULT_STATUSES = [\n    'New',\n    'Active',\n    'Closed'\n]\n\nDEFAULT_UPDATE_INCIDENT_STATUSES = [\n    'Resolved',\n    'Dismissed',\n    'TruePositive',\n    'FalsePositive',\n    'Other'\n]\n\nDEFAULT_TRIGGER_OPERATORS = [\n    'GreaterThan',\n    'LessThan',\n    'Equal',\n    'NotEqual'\n]\n\nDEFAULT_CLOSE_REASONS = [\n    \"True Positive - suspicious activity\",\n    \"Benign Positive - suspicious but expected\",\n    \"False Positive - incorrect alert logic\",\n    \"False Positive - inaccurate data\",\n    \"Undetermined\"\n]\n\nCLOSE_REASON_DELIMITER = '-'\n\nDEFAULT_TACTICS = [\n    'InitialAccess',\n    'Execution',\n    'Persistence',\n    'PrivilegeEscalation',\n    'DefenseEvasion',\n    'CredentialAccess',\n    'Discovery',\n    'LateralMovement',\n    'Collection',\n    'Exfiltration',\n    'CommandAndControl'\n]\n\nDEFAULT_TIME_FRAME = 3\n\n\nclass QueryFilterKeyEnum(Enum):\n    ORDER_BY = '$orderBy'\n    LIMIT = '$top'\n    START_TIME = 'startTime'\n    END_TIME = 'endTime'\n    TIME_SPAN = 'timespan'\n    FILTER = '$filter'\n\n\nclass ExtendedMicrosoftAzureSentinelManager(object):\n    \"\"\"\n    MicrosoftAzureSentinel Manager\n    \"\"\"\n    def __init__(\n            self,\n            api_root,\n            client_id,\n            client_secret,\n            tenant_id,\n            workspace_id,\n            resource,\n            subscription_id,\n            login_url,\n            verify_ssl=False,\n            logger=None,\n            force_check_connectivity=False\n    ):\n        self.api_root = api_root\n        self.client_id = client_id\n        self.client_secret = client_secret\n        self.tenant_id = tenant_id\n        self.workspace_id = workspace_id\n        self.session = requests.Session()\n        self.session.verify = verify_ssl\n        self.session.headers = HEADERS\n        self.resource = resource\n        self.subscription_id = subscription_id\n        self.login_url = login_url\n        self.verify_ssl = verify_ssl\n        self.token = self.fetch_token()\n        self.session.headers.update({\"Authorization\": f'Bearer {self.token}'})\n        self.logger = LOGGER(logger)\n        self.sentinel_parser = MicrosoftAzureSentinelParser(self.logger)\n        self.sentinel_common = MicrosoftAzureSentinelCommon(self.logger)\n        self.base_url = self._get_base_url()\n\n        if force_check_connectivity:\n            self.test_connectivity()\n\n    @classmethod\n    def get_api_error_message(cls, exception):\n        \"\"\"\n        Get API error message\n        :param exception: {Exception} The api error\n        :return: {str} error message\n        \"\"\"\n        context = exception.response.content.decode()\n        try:\n            return exception.response.json().get('error', {}).get('message') or context\n        except:\n            return context\n\n    @classmethod\n    def validate_response(cls, response, error_msg='An error occurred'):\n        # type: (requests.Response, str) -> None\n        \"\"\"\n        Login Response Validation\n        @param response: API Response\n        @param error_msg: Error message to change raised one\n        \"\"\"\n        try:\n            response.raise_for_status()\n        except requests.HTTPError as error:\n            error_message = cls.get_api_error_message(error) or error_msg\n\n            if response.status_code == 429:\n                raise MicrosoftAzureSentinelTimeoutError(error_message)\n\n            if response.status_code == 504:\n                raise MicrosoftAzureSentinelManagerError(\n                    f\"Search didn't completed due to timeout. Error: {error_message}\")\n\n            if response.status_code == 409:\n                raise MicrosoftAzureSentinelConflictError(error_message)\n\n            if response.status_code == 404:\n                raise MicrosoftAzureSentinelNotFoundError(error_message)\n\n            if response.status_code == 403:\n                raise MicrosoftAzureSentinelPermissionError(error_message)\n\n            if response.status_code == 401:\n                raise MicrosoftAzureSentinelUnauthorizedError(error_message)\n\n            if response.status_code == 400:\n                raise MicrosoftAzureSentinelBadRequestError(error_message)\n\n            raise MicrosoftAzureSentinelManagerError(f'{error_msg}: {error} {error_message}')\n\n        if not response.ok:\n            raise\n\n    def _remove_session_header(self, header):\n        if self._has_session_header(header):\n            del self.session.headers[header]\n\n    def _add_session_header(self, header, value):\n        self.session.headers[header] = value\n\n    def _has_session_header(self, header):\n        return header in self.session.headers\n\n    def _get_base_url(self):\n        return self._get_endpoint_url(\n            url_id='base_url',\n            api_root=self.api_root,\n            subscriptions=self.subscription_id,\n            resource=self.resource,\n            workspace=self.workspace_id)\n\n    def test_connectivity(self):\n        try:\n            response = self.session.get(\n                self._get_full_url('ping'),\n                params={\n                    'api-version': self._get_endpoint_version('ping'),\n                    QueryFilterKeyEnum.LIMIT.value: 1\n                })\n            self.validate_response(response)\n        except Exception as e:\n            raise MicrosoftAzureSentinelManagerError(f'Failed to connect to the Azure Sentinel Workspace. Reason: {e}')\n\n    def fetch_token(self):\n        # type: () -> str\n        \"\"\"\n        Fetch authentication token for Devices payloads.\n        @return: Access token\n        \"\"\"\n        url = urljoin(self.login_url, LOGIN_ENDPOINT.format(self.tenant_id))\n        response = requests.post(\n            url,\n            data={\n                \"grant_type\": \"client_credentials\",\n                \"client_id\": self.client_id,\n                \"resource\": self.api_root,\n                \"client_secret\": self.client_secret\n            },\n            verify=self.verify_ssl\n        )\n        self.validate_login_response(response, \"Failed to connect to the Azure Sentinel Workspace\")\n        access_token = response.json().get('access_token')\n\n        if access_token:\n            return access_token\n\n        raise MicrosoftAzureSentinelManagerError(\"Failed fetching token. Error code: {}. Description: {}\".format(\n            response.status_code,\n            response.json().get(\"error_description\", response.content))\n        )\n\n    def _get_full_url(self, url_id, **kwargs):\n        \"\"\"\n        Get full url for session.\n        :param url_id: {str} The id of url\n        :param kwargs: {dict} Variables passed for string formatting\n        :return: {str} The full url\n        \"\"\"\n        url = urljoin(self.base_url, self._get_endpoint_url(url_id).format(**kwargs))\n\n        return url\n\n    def _get_endpoint_version(self, url_id):\n        \"\"\"\n        Get version for endpoint\n        :param url_id: {str} The id of url\n        :return: {str} Endpoint version\n        \"\"\"\n        return API_ENDPOINTS[url_id]['version']\n\n    def _get_endpoint_url(self, url_id, **kwargs):\n        \"\"\"\n        Get version for endpoint\n        :param url_id: {str} The id of url\n        :return: {str} Endpoint url\n        \"\"\"\n        url = API_ENDPOINTS[url_id]['url']\n        if kwargs:\n            return url.format(**kwargs)\n\n        return url\n\n    def get_alert_rules(self, severities=None, types=None, tactics=None, only_enabled_rules=False, limit=None):\n        # type: (list, list, list, bool, int) -> [object]\n        \"\"\"\n        Get all alert rules including filters\n        @param severities: Severities list of the alert rules to look for\n        @param types: Alert types\n        @param tactics: Alert rule tactics\n        @param only_enabled_rules: Only enabled alert rules\n        @param limit: returned alert rules count\n        @return: List of the alert rules\n        \"\"\"\n        url = self._get_full_url('alert_rules_listing')\n        params = {\n            'api-version': self._get_endpoint_version('alert_rules_listing')\n        }\n\n        response = self.session.get(url, params=params)\n        self.validate_response(response)\n        alert_rules_list = self.sentinel_parser.build_results(response.json(), 'build_siemplify_alert_rule_obj')\n\n        return self._filter_alert_rules(alert_rules_list, severities, types, tactics, only_enabled_rules, limit)\n\n    def get_alert_rule(self, alert_rule_id):\n        \"\"\"\n        Get alert rule by ID\n        @param alert_rule_id: ID of the alert rule\n        @return: {AlertRule} instance\n        \"\"\"\n        params = {\n            'api-version': self._get_endpoint_version('alert_rules')\n        }\n        response = self.session.get(self._get_full_url('alert_rules', alert_rule_id=alert_rule_id), params=params)\n        self.validate_response(response)\n\n        return self.sentinel_parser.build_siemplify_alert_rule_obj(response.json())\n\n    def create_alert_rule(self, enable_alert_rule, name, severity, query, frequency, lookup_period, trigger_operator,\n                          trigger_threshold, enable_suppression, suppression_duration, description=None, tactics=None):\n        # type: (bool, str, str, str, str, str, str, int, bool, str, str, list) -> object\n        \"\"\"\n        Create new alert rule\n        @param enable_alert_rule: Enables or Disables alert rule\n        @param name: Alert Rule name\n        @param severity: Alert Rule severity\n        @param query: Alert rule query\n        @param frequency: How frequently to run the query\n        @param lookup_period: Time of the last lookup data\n        @param trigger_operator: Alert Rule trigger operator\n        @param trigger_threshold: Alert Rule trigger threshold\n        @param enable_suppression: Whether you want to stop running query after alert is generated\n        @param suppression_duration: How long you want to stop running query after alert is generated\n        @param description: Alert Rule description\n        @param tactics: Alert Rule tactics\n        @return: New Alert Rule\n        \"\"\"\n        params = {\n            'api-version': self._get_endpoint_version('alert_rules')\n        }\n\n        json_payload = {\n            'properties': {\n                'enabled': enable_alert_rule,\n                'displayName': name,\n                'severity': severity,\n                'query': query,\n                'queryFrequency': frequency,\n                'queryPeriod': lookup_period,\n                'triggerOperator': trigger_operator,\n                'triggerThreshold': trigger_threshold,\n                'suppressionEnabled': enable_suppression,\n                'suppressionDuration': suppression_duration,\n                'description': description,\n                'tactics': tactics\n            }\n        }\n\n        response = self.session.put(\n            self._get_full_url('alert_rules', alert_rule_id=uuid.uuid4()),\n            params=params,\n            json=json_payload\n        )\n        self.validate_response(response)\n\n        return self.sentinel_parser.build_siemplify_alert_rule_obj(response.json())\n\n    def update_alert_rule(self, alert_rule_id, enable_alert_rule=None, name=None, severity=None, query=None,\n                          frequency=None, lookup_period=None, trigger_operator=None, trigger_threshold=None,\n                          enable_suppression=None, suppression_duration=None, description=None, tactics=None):\n        # type: (str, bool, str, str, str, str, str, str, int, bool, str, str, list) -> object\n        \"\"\"\n        Update existing alert rule\n        @param alert_rule_id: ID of the Alert Rule to update\n        @param enable_alert_rule: Enables or Disables alert rule\n        @param name: Alert Rule name\n        @param severity: Alert Rule severity\n        @param query: Alert rule query\n        @param frequency: How frequently to run the query\n        @param lookup_period: Time of the last lookup data\n        @param trigger_operator: Alert Rule trigger operator\n        @param trigger_threshold: Alert Rule trigger threshold\n        @param enable_suppression: Whether you want to stop running query after alert is generated\n        @param suppression_duration: How long you want to stop running query after alert is generated\n        @param description: Alert Rule description\n        @param tactics: Alert Rule tactics\n        @return: Updated Alert Rule\n        \"\"\"\n        alert_rule = self.get_alert_rule(alert_rule_id)\n        json_payload = self.modify_alert_rule_json_payload(alert_rule, enable_alert_rule, name, severity, query,\n                                                           frequency, lookup_period, trigger_operator, trigger_threshold,\n                                                           enable_suppression, suppression_duration, description,\n                                                           tactics)\n        params = {\n            'api-version': self._get_endpoint_version('alert_rules')\n        }\n\n        response = self.session.put(\n            self._get_full_url('alert_rules', alert_rule_id=alert_rule_id),\n            params=params,\n            json=json_payload\n        )\n        self.validate_response(response)\n\n        return self.sentinel_parser.build_siemplify_alert_rule_obj(response.json())\n\n    def modify_alert_rule_json_payload(self, alert_rule, enable_alert_rule=None, name=None,\n                                       severity=None, query=None, frequency=None, lookup_period=None,\n                                       trigger_operator=None, trigger_threshold=None, enable_suppression=None,\n                                       suppression_duration=None, description=None, tactics=None):\n        \"\"\"\n        Get updating modified data\n        @param alert_rule: AlertRule object\n        @param enable_alert_rule: Enables or Disables alert rule\n        @param name: Alert Rule name\n        @param severity: Alert Rule severity\n        @param query: Alert rule query\n        @param frequency: How frequently to run the query\n        @param lookup_period: Time of the last lookup data\n        @param trigger_operator: Alert Rule trigger operator\n        @param trigger_threshold: Alert Rule trigger threshold\n        @param enable_suppression: Whether you want to stop running query after alert is generated\n        @param suppression_duration: How long you want to stop running query after alert is generated\n        @param description: Alert Rule description\n        @param tactics: Alert Rule tactics\n        @return: Updated Alert Rule\n        \"\"\"\n        alert_rule_data = alert_rule.get_original_data()\n\n        tactics = alert_rule.properties.tactics + [tactic for tactic in tactics if tactic not in alert_rule.properties.tactics]\n        properties = {\n            'enabled': enable_alert_rule,\n            'displayName': name,\n            'severity': severity,\n            'query': query,\n            'queryFrequency': frequency,\n            'queryPeriod': lookup_period,\n            'triggerOperator': trigger_operator,\n            'triggerThreshold': trigger_threshold,\n            'suppressionEnabled': enable_suppression,\n            'suppressionDuration': suppression_duration,\n            'description':  description,\n            'tactics': list(set(tactics))\n        }\n        properties = {key: value for key, value in properties.items() if value is not None}\n        # READ-ONLY field\n        del alert_rule_data['properties']['lastModifiedUtc']\n        alert_rule_data['properties'].update(properties)\n\n        return alert_rule_data\n\n    def delete_alert_rule(self, alert_rule_id):\n        # type: (str) -> None\n        \"\"\"\n        Delete Alert Rule\n        @param alert_rule_id: ID of the Alert Rule to delete\n        \"\"\"\n        # To check if alert exists\n        self.get_alert_rule(alert_rule_id=alert_rule_id)\n        params = {\n            'api-version': self._get_endpoint_version('alert_rules')\n        }\n\n        response = self.session.delete(self._get_full_url('alert_rules', alert_rule_id=alert_rule_id), params=params)\n        self.validate_response(response)\n\n    def get_custom_hunting_rules(self, names=None, tactics=None, limit=None):\n        # type: (list, list, int) -> [object]\n        \"\"\"\n        Get all Custom Hunting Rules including filters\n        @param names: Custom Hunting Rules names\n        @param tactics: Custom Hunting Rules tactics\n        @param limit: Limited items to return\n        @return: Filtered Custom Hunting Rules\n        \"\"\"\n        params = {\n            'api-version': self._get_endpoint_version('custom_hunting_rules_listing'),\n            QueryFilterKeyEnum.LIMIT.value: limit\n        }\n        response = self.session.get(\n            self._get_full_url('custom_hunting_rules_listing'),\n            params=params\n        )\n        hunting_rules = self.sentinel_parser.build_results(response.json(), 'build_siemplify_custom_hunting_rule_obj')\n\n        return self._filter_custom_hunting_rules(hunting_rules, names, tactics)[:limit]\n\n    def get_custom_hunting_rule(self, custom_hunting_rule_id):\n        # type: (str) -> object\n        \"\"\"\n        Get specific Custom Hunting Rule\n        @param custom_hunting_rule_id: Custom Hunting Rule ID\n        @return: Custom Hunting Rule\n        \"\"\"\n        hunting_rule = self._get_custom_hunting_rule(custom_hunting_rule_id)\n\n        return self.sentinel_parser.build_siemplify_custom_hunting_rule_obj(hunting_rule)\n\n    def _get_custom_hunting_rule(self, custom_hunting_rule_id):\n        params = {\n            'api-version': self._get_endpoint_version('custom_hunting_rules'),\n        }\n        response = self.session.get(\n            self._get_full_url('custom_hunting_rules', custom_hunting_rule_id=custom_hunting_rule_id),\n            params=params\n        )\n        self.validate_response(response)\n\n        return response.json()\n\n    def create_custom_hunting_rule(self, query, display_name, description=None, tactics=None):\n        # type: (str, str, str, list) -> object\n        \"\"\"\n        Create new Custom Hunting Rule\n        @param query: Custom Hunting Rule query\n        @param display_name: Custom Hunting Ruled display name\n        @param description: Custom Hunting Rule description\n        @param tactics: Custom Hunting Rule tactics\n        @return: New Custom Hunting Rule\n        \"\"\"\n        params = {\n            'api-version': self._get_endpoint_version('custom_hunting_rules'),\n        }\n\n        tags = TagCollection()\n\n        if tactics:\n            tags.set_from_list('tactics', tactics)\n        if description:\n            tags.set('description', description)\n\n        custom_hunting_rule = CustomHuntingRuleRequest()\n        custom_hunting_rule.name = custom_hunting_rule.id = uuid.uuid4()\n        custom_hunting_rule.properties.query = query\n        custom_hunting_rule.properties.display_name = display_name\n        custom_hunting_rule.properties.tags = tags\n\n        response = self.session.put(\n            self._get_full_url('custom_hunting_rules', custom_hunting_rule_id=custom_hunting_rule.id),\n            params=params,\n            json=custom_hunting_rule.to_create_json()\n        )\n        self.validate_response(response)\n\n        return self.sentinel_parser.build_siemplify_custom_hunting_rule_obj(response.json())\n\n    def update_custom_hunting_rule(self, custom_hunting_rule_id, display_name=None, query=None, description=None,\n                                   tactics=None):\n        # type: (str, str, str, str, list) -> object\n        \"\"\"\n        Update existing Custom Hunting Rule\n        @param custom_hunting_rule_id: Custom Hunting Rule ID\n        @param display_name: Custom Hunting Rule display name\n        @param query: Custom Hunting Rule query\n        @param description: Custom Hunting Rule description\n        @param tactics: Custom Hunting Rule tactics\n        @return: Updated Custom Hunting Rule\n        \"\"\"\n        hunting_rule = self._get_custom_hunting_rule(custom_hunting_rule_id)\n        custom_hunting_rule = self.sentinel_parser.build_siemplify_custom_hunting_rule_req_obj(hunting_rule)\n\n        display_name_to_update = display_name or custom_hunting_rule.properties.display_name\n        custom_hunting_rule.properties.display_name = display_name_to_update\n\n        query_to_update = query or custom_hunting_rule.properties.query\n        custom_hunting_rule.properties.query = query_to_update\n\n        if description:\n            custom_hunting_rule.properties.tags.remove_all('description')\n            custom_hunting_rule.properties.tags.set('description', description)\n\n        if tactics:\n            custom_hunting_rule.properties.tags.set_from_list_unique_values(name='tactics', values=tactics,\n                                                                            unique_tag_name='tactics')\n        response = self.session.put(\n            self._get_full_url('custom_hunting_rules', custom_hunting_rule_id=custom_hunting_rule_id),\n            params={'api-version': self._get_endpoint_version('custom_hunting_rules')},\n            json=custom_hunting_rule.to_update_json()\n        )\n        self.validate_response(response)\n\n        return self.sentinel_parser.build_siemplify_custom_hunting_rule_obj(response.json())\n\n    def delete_custom_hunting_rule(self, custom_hunting_rule_id):\n        # type: (str) -> None\n        \"\"\"\n        Delete Custom Hunting Rule\n        @param custom_hunting_rule_id: Custom Hunting Rule ID\n        \"\"\"\n        # To check if custom hunting rule exists\n        self.get_custom_hunting_rule(custom_hunting_rule_id=custom_hunting_rule_id)\n\n        params = {\n            'api-version': self._get_endpoint_version('custom_hunting_rules'),\n        }\n\n        response = self.session.delete(\n            self._get_full_url('custom_hunting_rules', custom_hunting_rule_id=custom_hunting_rule_id),\n            params=params\n        )\n        self.validate_response(response)\n\n    def run_custom_hunting_rule(self, custom_hunting_rule_id, timeout=None):\n        # type: (str, int) -> object\n        \"\"\"\n        Run query of Custom Hunting Rule\n        @param custom_hunting_rule_id: Custom Hunting Rule ID\n        @param timeout: timeout value for the Azure Sentinel hunting rule API call.\n        @return: Query Result\n        \"\"\"\n        custom_hunting_rule = self.get_custom_hunting_rule(custom_hunting_rule_id)\n\n        return self.run_kql_query(custom_hunting_rule.properties.query, timeout=timeout)\n\n    def run_kql_query(self, query, timespan=None, timeout=None, duration=None, limit=None):\n        # type: (str, str, int, str, int) -> object or list\n        \"\"\"\n        Run query\n        @param query: Query\n        @param timespan: Time span to look for\n        @param timeout: timeout value for the Azure Sentinel hunting rule API call\n        @param duration: Duration (servertimeout)\n        @param limit: How much results should be fetched\n        @return: Query Result\n        \"\"\"\n        params = {\n            'api-version': self._get_endpoint_version('kql_query'),\n            'timespan': timespan,\n        }\n\n        json_request = {\n            'query': f'{query} | limit {limit}' if limit else query,\n            'servertimeout': duration\n        }\n\n        json_request = {k: v for k, v in json_request.items() if v}\n\n        if timeout:\n            self._add_session_header('Prefer', f'wait={timeout}')\n\n        response = self.session.post(self._get_full_url('kql_query'), params=params, json=json_request)\n\n        self._remove_session_header('Prefer')\n\n        self.validate_response(response)\n\n        query_result = self.sentinel_parser.build_results(\n            raw_json=response.json(),\n            method='build_siemplify_primary_result_obj',\n            data_key='tables'\n        )\n\n        return query_result and query_result[0]\n\n    def get_incidents_by_filter(self, creation_time=None, time_frame=None, statuses=None, severities=None, limit=None,\n                                asc=False):\n        # type: (datetime, int, list, list, int, bool) -> [object]\n        \"\"\"\n        Get all Incidents including filters\n        @param creation_time: Get incidents with creationTimeUtc greater than passed datetime\n        @param time_frame: Time frame for which to show the statistics\n        @param statuses: Statuses of the incidents to look for\n        @param severities: Severities of the incidents to look for\n        @param limit: How much results should be fetched\n        @param asc: Whether to bring incidents in ascending or descending order\n        @return: Incidents\n        \"\"\"\n        params = {\n            'api-version': self._get_endpoint_version('incidents'),\n        }\n\n        query = str(QueryBuilder([\n            Condition(field='properties/createdTimeUtc', operator=OperatorEnum.GE.value,\n                      value_formatter=('format_time', TIME_FORMAT), value=creation_time),\n            Condition(field='properties/createdTimeUtc', operator=OperatorEnum.GE.value,\n                      value_formatter=('set_hours_back', TIME_FORMAT), value=time_frame),\n            Condition(field='properties/status', operator=OperatorEnum.EQ.value, value=statuses,\n                      value_with_quotes=True, join_values_with=QueryOperatorEnum.OR.value),\n            Condition(field='properties/severity', operator=OperatorEnum.EQ.value, value=severities,\n                      value_with_quotes=True, join_values_with=QueryOperatorEnum.OR.value)\n        ]))\n        if query:\n            params[QueryFilterKeyEnum.FILTER.value] = query\n\n        if asc:\n            params[QueryFilterKeyEnum.ORDER_BY.value] = 'properties/createdTimeUtc asc'\n\n        if limit:\n            params[QueryFilterKeyEnum.LIMIT.value] = limit\n\n        response = self.session.get(self._get_full_url('incidents'), params=params)\n        self.validate_response(response)\n\n        return self.sentinel_parser.build_results(response.json(), 'build_siemplify_incident_obj', limit=limit)\n\n    def get_incidents(self, creation_time=None, time_frame=None, statuses=None, severities=None, limit=None, extend_alerts=False,\n                      asc=True):\n        # type: (datetime, int, list, list, int, bool, bool) -> [object]\n        \"\"\"\n        Get all Incidents including filters\n        @param creation_time: Get incidents with creationTimeUtc greater than passed datetime\n        @param time_frame: Time frame for which to show the statistics\n        @param statuses: Statuses of the incidents to look for\n        @param severities: Severities of the incidents to look for\n        @param limit: How much results should be fetched\n        @param extend_alerts: Convert\n        @param asc: Whether to bring incidents in ascending or descending order\n        @return: Incidents\n        \"\"\"\n        api_parameters = self._build_api_parameters(\n            api_version=self._get_endpoint_version('incident_cases'),\n            creation_time=creation_time,\n            time_frame=time_frame,\n            statuses=statuses,\n            severities=severities,\n            asc=asc,\n            limit=limit\n        )\n\n        response = self.session.get(self._get_full_url('incident_cases'), params=api_parameters)\n        self.validate_response(response)\n\n        incidents_data = response.json().get('value')\n\n        incidents = []\n        for incident_data in incidents_data:\n            incident = self.sentinel_parser.build_siemplify_incident_obj(incident_data)\n\n            if extend_alerts:\n                if not incident.properties.related_alert_ids:\n                    self.logger.info(f'Incorrect formatted incident \"{incident.id}\". Skipping...')\n                    continue\n\n                incident.properties.alerts = self._get_alerts_by_id(*incident.properties.related_alert_ids,\n                                                                    incident_number=incident.properties.case_number)\n                for alert in incident.properties.alerts:\n                    alert['Events'] = self._get_alert_events(alert) \\\n                        if alert.get('ProviderName') == 'ASI Scheduled Alerts' else []\n\n            incidents.append(incident)\n\n        return incidents\n\n    def get_incidents_with_new_endpoint(self, creation_time=None, time_frame=None, statuses=None,\n                                        severities=None, limit=None, asc=True, use_same_approach=False,\n                                        existing_ids=None, next_page_link=None, connector_starting_time=None,\n                                        python_process_timeout=None, scheduled_alerts_events_limit=None,\n                                        incidents_alerts_limit_to_ingest=None, backlog_ids=None):\n        \"\"\"\n        Get all Incidents including filters\n        :param creation_time: {datetime} Get incidents with creationTimeUtc greater than passed datetime\n        :param time_frame: {int} Time frame for which to show the statistics\n        :param statuses: {list} Statuses of the incidents to look for\n        :param severities: {list} Severities of the incidents to look for\n        :param limit: {int} How much results should be fetched\n        :param asc: {bool} Whether to bring incidents in ascending or descending order\n        :param use_same_approach: {bool} Whether to use the same approach with event creation for all alert types\n        :param existing_ids: {list} The incident ids that were already processed\n        :param next_page_link: {str} The next page link, to use pagination across connector execution\n        :param connector_starting_time: {int} Connector start time\n        :param python_process_timeout: {int} The python process timeout\n        :param scheduled_alerts_events_limit: {int} Limit for scheduled alerts events\n        :param incidents_alerts_limit_to_ingest: {int} Limit for alerts per single Azure Sentinel incident\n        :param backlog_ids: {dict} Backlog ids dict\n        :return: {list} List of Incident objects\n        \"\"\"\n        api_parameters = self._build_api_parameters(\n            api_version=self._get_endpoint_version('incidents'),\n            creation_time=creation_time,\n            time_frame=time_frame,\n            statuses=statuses,\n            severities=severities,\n            asc=asc,\n            limit=limit\n        )\n\n        request_url, api_parameters = (next_page_link, None) if next_page_link else \\\n            (self._get_full_url('incidents'), api_parameters)\n\n        response = self.session.get(request_url, params=api_parameters)\n\n        self.validate_response(response)\n\n        json_response = response.json()\n        next_page_link = self.sentinel_parser.get_next_page_link(json_response)\n\n        incidents_data = json_response.get('value')\n\n        incidents = self.adjust_incidents_alert(incidents_data, existing_ids, use_same_approach,\n                                                connector_starting_time=connector_starting_time,\n                                                python_process_timeout=python_process_timeout,\n                                                scheduled_alerts_events_limit=scheduled_alerts_events_limit,\n                                                incidents_alerts_limit_to_ingest=incidents_alerts_limit_to_ingest,\n                                                backlog_ids=backlog_ids)\n\n        return incidents, next_page_link\n\n    def adjust_incidents_alert(self, incidents_data, existing_ids, use_same_approach,\n                               connector_starting_time=None, python_process_timeout=None,\n                               scheduled_alerts_events_limit=None, incidents_alerts_limit_to_ingest=None,\n                               backlog_ids=None):\n        \"\"\"\n        Update incident data\n        :param incidents_data: {list} Incidents json\n        :param existing_ids: {list} The incident ids that were already processed\n        :param use_same_approach: {bool} Whether to use the same approach with event creation for all alert types\n        :param connector_starting_time: {int} Connector start time\n        :param python_process_timeout: {int} The python process timeout\n        :param scheduled_alerts_events_limit: {int} Limit for scheduled alerts events\n        :param incidents_alerts_limit_to_ingest: {int} Limit for alerts per single Azure Sentinel incident\n        :param backlog_ids: {dict} Backlog ids dict\n        return {list} List of Incident objets\n        \"\"\"\n        incidents = []\n        fetched_incidents = []\n        MicrosoftAzureSentinelCommon.raise_if_timeout(connector_starting_time, python_process_timeout)\n        for incident_data in incidents_data:\n            incident = self.sentinel_parser.build_siemplify_incident_obj(incident_data)\n            fetched_incidents.append(incident)\n\n        MicrosoftAzureSentinelCommon.raise_if_timeout(connector_starting_time, python_process_timeout)\n\n        filtered_incidents = self.sentinel_common.filter_old_ids(fetched_incidents, existing_ids)\n\n        for incident in filtered_incidents:\n            MicrosoftAzureSentinelCommon.raise_if_timeout(connector_starting_time, python_process_timeout)\n            incident.properties.alerts = self.get_incident_alerts_by_id(incident.name)\n            incident_alerts = []\n\n            for alert in incident.properties.alerts:\n                MicrosoftAzureSentinelCommon.raise_if_timeout(connector_starting_time, python_process_timeout)\n                if len(incident_alerts) >= incidents_alerts_limit_to_ingest:\n                    self.logger.info(f\"Incident's {incident.name} Alerts Limit to Ingest was reached,\"\n                                     f\" no more alerts will be processed.\")\n                    break\n\n                if not use_same_approach and alert.properties.product_component_name in ALERT_TYPES_WITH_EVENTS:\n                    MicrosoftAzureSentinelCommon.raise_if_timeout(connector_starting_time, python_process_timeout)\n                    alerts_with_old_api = self._get_alerts_by_id(alert.properties.system_alert_id,\n                                                                 incident_number=incident.properties.incident_number)\n\n                    if alerts_with_old_api:\n                        incident_alerts.extend(alerts_with_old_api)\n\n                        for scheduled_alert in alerts_with_old_api:\n                            MicrosoftAzureSentinelCommon.raise_if_timeout(connector_starting_time,\n                                                                          python_process_timeout)\n                            try:\n                                scheduled_alert['Events'] = self._get_alert_events(scheduled_alert,\n                                                                                   scheduled_alerts_events_limit)\n                            except Exception:\n                                scheduled_alert['Events'] = []\n                                self.logger.error(\n                                    f\"Failed to process Azure Sentinel Scheduled Alert with id {incident.name} and \"\n                                    f\"incident number {incident.properties.incident_number}! Query field of the \"\n                                    f\"affected alert: \\\"{json.loads(scheduled_alert.get('ExtendedProperties')).get('Query')}\\\"\")\n                        continue\n                    else:\n                        self.logger.error(f\"Failed to fetch incident {incident.properties.incident_number} scheduled \"\n                                          f\"or NRT alerts. Will send it to backlog.\")\n                else:\n                    MicrosoftAzureSentinelCommon.raise_if_timeout(connector_starting_time, python_process_timeout)\n\n                    if len(incident.properties.alerts) == 1:\n                        alert.entities = self.get_incident_entities(alert.properties.system_alert_id,\n                                                                    incident.properties.incident_number,\n                                                                    incident.name,\n                                                                    backlog_ids)\n                    else:\n                        alert.entities = self.get_alert_entities(alert.properties.system_alert_id,\n                                                                 incident.properties.incident_number,\n                                                                 incident.name,\n                                                                 backlog_ids)\n                    incident_alerts.append(alert)\n\n            incident.properties.alerts = incident_alerts\n            incidents.append(incident)\n\n        return sorted(incidents, key=lambda _alert: _alert.properties.created_time_unix)\n\n    def get_incident_alerts_by_id(self, incident_id):\n        \"\"\"\n        Get Azure Sentinel alerts related to  specific incident.\n        :param incident_id: {str} ID of the incident\n        :return: {list} List of Alert objects\n        \"\"\"\n        url = '{}{}'.format(self.base_url, API_ENDPOINTS['GET_INCIDENT_ALERTS']['URL'].format(incident_name=incident_id))\n        api_parameters = self._build_api_parameters(api_version=API_ENDPOINTS['GET_INCIDENT_ALERTS']['VERSION'])\n\n        response = self.session.post(url, params=api_parameters)\n        self.validate_response(response)\n        alerts_data = response.json().get('value', [])\n        return [self.sentinel_parser.build_siemplify_incident_alert_obj(alert_data) for alert_data in alerts_data] \\\n            if alerts_data else []\n\n    def get_alert_entities(self, alert_id, incident_number, incident_id, backlog_ids):\n        \"\"\"\n        Get Azure Sentinel  entities related to  specific alert from the incident.\n        :param alert_id: {str} Id of the alert\n        :param incident_number: {int} The number of the incident\n        :param incident_id: {str} ID of the incident\n        :param backlog_ids: {dict} Backlog ids dict\n        :return: {list} List of Entity objects\n        \"\"\"\n        url = '{}{}'.format(self.base_url, API_ENDPOINTS['GET_ALERT_ENTITIES']['URL'].format(alert_id=alert_id))\n        params = {\n            'api-version': API_ENDPOINTS['GET_ALERT_ENTITIES']['VERSION']\n        }\n        payload = {\n            'expansionId': API_ENDPOINTS['GET_ALERT_ENTITIES']['DEFAULT_EXPANSION_ID']\n        }\n\n        response = self.session.post(url, json=payload, params=params)\n\n        try:\n            self.validate_response(response)\n        except Exception as e:\n            if isinstance(e, MicrosoftAzureSentinelTimeoutError):\n                raise \n            if incident_number not in backlog_ids:\n                self.logger.error(\"Failed to fetch alert {} entities. Will send it to backlog. Incident {}\".\n                                  format(alert_id, incident_id))\n            return None\n\n        response_data = response.json().get('value', {})\n        edges_data = response_data.get('edges', [])\n        return [self.sentinel_parser.build_siemplify_alert_entity_obj(\n            entity_data, next((edge.get('additionalData', {}) for edge in edges_data if edge.get('targetEntityId')\n                               == entity_data.get('id')), None)) for entity_data in response_data.get('entities', [])]\n\n    def get_incident_by_number(self, incident_number, use_same_approach=False,\n                               scheduled_alerts_events_limit=None, backlog_ids=None):\n        \"\"\"\n        Get incident by its number\n        :param incident_number: {int} The number of the incident\n        :param use_same_approach: {bool} Whether to use the same approach with event creation for all alert types\n        :param scheduled_alerts_events_limit: {int} Limit for scheduled alerts events\n        :param backlog_ids: (dict} Backlog IDs dict\n        :return: Incident\n        \"\"\"\n        params = {\n            'api-version': self._get_endpoint_version('incidents'),\n            QueryFilterKeyEnum.FILTER.value: 'properties/incidentNumber eq {}'.format(incident_number)\n        }\n        response = self.session.get(self._get_full_url('incidents'), params=params)\n        self.validate_response(response)\n        incident_data = response.json().get('value')\n\n        if not incident_data:\n            raise MicrosoftAzureSentinelManagerError('Incident with number {} was not found'.format(incident_number))\n\n        incident = self.sentinel_parser.build_siemplify_incident_obj(incident_data[0])\n        incident.properties.alerts = self.get_incident_alerts_by_id(incident.name)\n        incident_alerts_with_old_api = []\n\n        for alert in incident.properties.alerts:\n            if not use_same_approach and alert.properties.product_component_name in ALERT_TYPES_WITH_EVENTS:\n                alerts_with_old_api = self._get_alerts_by_id(alert.properties.system_alert_id,\n                                                             incident_number=incident_number)\n                if alerts_with_old_api:\n                    incident_alerts_with_old_api.extend(alerts_with_old_api)\n                    incident.properties.alerts = incident_alerts_with_old_api\n\n                    for scheduled_alert in alerts_with_old_api:\n                        scheduled_alert['Events'] = self._get_alert_events(scheduled_alert, scheduled_alerts_events_limit)\n\n                    continue\n            else:\n                if len(incident.properties.alerts) == 1:\n                    alert.entities = self.get_incident_entities(alert.properties.system_alert_id, incident_number,\n                                                                incident.name, backlog_ids)\n                else:\n                    alert.entities = self.get_alert_entities(alert.properties.system_alert_id, incident_number,\n                                                             incident.name, backlog_ids)\n        return incident\n\n    def get_incident_statistics(self, time_frame=None):\n        # type: (int) -> object\n        \"\"\"\n        Get Incident statistic\n        @param time_frame: Time frame for which to show the statistics\n        @return: IncidentStatistic instance\n        \"\"\"\n        params = {'api-version': self._get_endpoint_version('incident_aggregation')}\n\n        end_time = datetime.utcnow()\n        start_time = end_time - timedelta(hours=time_frame)\n\n        params[QueryFilterKeyEnum.START_TIME.value] = start_time.strftime(TIME_FORMAT)\n\n        params[QueryFilterKeyEnum.END_TIME.value] = end_time.strftime(TIME_FORMAT)\n\n        response = self.session.get(self._get_full_url('incident_aggregation'), params=params)\n        self.validate_response(response)\n\n        return self.sentinel_parser.build_siemplify_incident_statistic_obj(response.json())\n\n    def get_incident_by_incident_number(self, incident_number):\n        return self._get_incident_by_incident_number(incident_number=incident_number)\n\n    def add_comment_to_incident(self, incident_name, comment):\n        \"\"\"\n        Add Comment to the incident\n        @param incident_name: {str} Incident number\n        @param comment: {str} comment to add to Incident\n        @return: {Incident} updated incident details\n        \"\"\"\n        params = {'api-version': self._get_endpoint_version('incident_comment')}\n        json_payload = {\n            'properties': {\n                'message': comment\n            }\n        }\n\n        response = self.session.put(\n            self._get_full_url('incident_comment', incident_number=incident_name, incident_comment_id=uuid.uuid4()),\n            params=params,\n            json=json_payload\n        )\n        self.validate_response(response)\n\n        return self.sentinel_parser.build_siemplify_incident_obj(raw_json=response.json())\n\n    def _get_incident_by_incident_number(self, incident_number):\n        \"\"\"\n        Update existing Incident\n        @param incident_number: {str} Incident number\n        @return: {Incident} instance\n        \"\"\"\n        filter_query = QueryBuilder([\n            Condition(field='properties/incidentNumber', operator='eq', value=incident_number)\n        ])\n        params = {\n            'api-version': self._get_endpoint_version('incidents'),\n            QueryFilterKeyEnum.FILTER.value: str(filter_query)\n        }\n\n        response = self.session.get(self._get_full_url('incidents'), params=params)\n        self.validate_response(response)\n\n        incident = self.sentinel_parser.build_results(response.json(), 'build_siemplify_incident_obj')\n\n        if incident:\n            return incident[0]\n\n    def update_incident_labels(self, incident_number, labels=None):\n        \"\"\"\n        Update existing Incident\n        @param incident_number: {str} Incident by number to update\n        @param labels: {list} Incident labels\n        @return: Updated Incident\n        \"\"\"\n        incident = self._get_incident_by_incident_number(incident_number)\n\n        url = self._get_full_url('incident', incident_name=incident.name)\n        params = {\n            'api-version': self._get_endpoint_version('incident'),\n        }\n        json_payload, updated_labels, not_updated_labels = incident.update_labels(labels)\n\n        response = self.session.put(url, params=params, json=json_payload)\n        self.validate_response(response)\n\n        return self.sentinel_parser.build_siemplify_incident_obj(response.json()), updated_labels, not_updated_labels\n\n    def update_incident(self, incident_number, title=None, status=None, severity=None, description=None,\n                        assigned_to=None, close_reason=None, closing_comment=None):\n        # type: (int, str, str, str, str, str, str, list) -> object\n        \"\"\"\n        Update existing Incident\n        @param incident_number: Number of Incident to be updated\n        @param title: Incident title\n        @param status: Incident status\n        @param severity: Incident severity\n        @param description: Incident description\n        @param assigned_to: Incident assignee\n        @param close_reason: Incident close reason\n        @param closing_comment: Closing comment\n        @return: Updated Incident\n        \"\"\"\n        incident = self._get_incident_by_incident_number(incident_number)\n        params = {\n            'api-version': self._get_endpoint_version('incident')\n        }\n        json_payload = self.update_incident_payload(incident.get_original_data(), title, status, severity, description,\n                                                    assigned_to, close_reason, closing_comment)\n        response = self.session.put(\n            self._get_full_url('incident', incident_name=incident.name),\n            params=params,\n            json=json_payload\n        )\n        self.validate_response(response)\n\n        return self.sentinel_parser.build_siemplify_incident_obj(response.json())\n\n    def update_incident_payload(self, data, title=None, status=None, severity=None, description=None, assigned_to=None,\n                                close_reason=None, closing_comment=None):\n        \"\"\"\n        Update existing Incident\n        @param data: Incident data\n        @param title: Incident title\n        @param status: Incident status\n        @param severity: Incident severity\n        @param description: Incident description\n        @param assigned_to: Incident assignee\n        @param close_reason: Incident close reason\n        @param closing_comment: Closing comment\n        @return: {dict} Updated Incident data\n        \"\"\"\n        if title:\n            data['properties']['title'] = title\n\n        if status and status not in ADDITIONAL_DEFAULT_FOR_VALIDATION:\n            data['properties']['status'] = status\n            # In case of when changing from close status to other\n            if status != CLOSED:\n                data['properties']['classification'] = ''\n                data['properties']['classificationReason'] = ''\n                data['properties']['classificationComment'] = ''\n\n        if severity and severity not in ADDITIONAL_DEFAULT_FOR_VALIDATION:\n            data['properties']['severity'] = severity\n\n        if description:\n            data['properties']['description'] = description\n\n        if assigned_to:\n            data['properties']['owner']['assignedTo'] = assigned_to\n\n        if close_reason and close_reason not in ADDITIONAL_DEFAULT_FOR_VALIDATION:\n            classification, classification_reason = self.modify_classification(close_reason)\n            data['properties']['classification'] = classification\n            data['properties']['classificationReason'] = classification_reason\n            data['properties']['classificationComment'] = closing_comment or ''\n\n        return data\n\n    def modify_classification(self, reason):\n        \"\"\"\n        Update incident reason\n        @param reason: {str} Incident closing reason\n        :return classification: {str} updated closing reason\n        \"\"\"\n        classifications_list = reason.split(CLOSE_REASON_DELIMITER)\n        reason = classifications_list[-1].replace(' ', '').capitalize() if len(classifications_list) > 1 else ''\n\n        return classifications_list[0].replace(' ', ''), reason\n\n    def _get_alerts_by_id(self, *ids, incident_number=None):\n        # type: (str) -> list\n        \"\"\"\n        Get all alerts by provided ids\n        @param ids: IDs of the alerts\n        @param incident_number: Number of the incident\n        @return: Alerts\n        \"\"\"\n        query = 'SecurityAlert | summarize arg_max(TimeGenerated, *) by SystemAlertId | where SystemAlertId in({})' \\\n            .format(', '.join([f'\\\"{x}\\\"' for x in ids]))\n\n        try:\n            return self.run_kql_query(query=query).to_json()\n        except MicrosoftAzureSentinelBadRequestError:\n            if incident_number:\n                self.logger.error(\n                    f\"Incident {incident_number} was skipped because it didn't had SystemAlertID value present on the \"\n                    'time of ingestion')\n                return []\n            raise\n\n    def _get_alert_events(self, alert, limit=None):\n        # type: (dict) -> list\n        \"\"\"\n        Get event list for alert\n        @param alert: Alert\n        @param limit {int}: Limit for results\n        @return: List of Events\n        \"\"\"\n        extended_properties = json.loads(alert.get('ExtendedProperties'))\n        start_time = convert_string_to_datetime(extended_properties.get('Query Start Time UTC'), \"UTC\")\\\n            .strftime(TIME_FORMAT)\n        end_time = convert_string_to_datetime(extended_properties.get('Query End Time UTC'), \"UTC\")\\\n            .strftime(TIME_FORMAT)\n\n        query = extended_properties.get('Query')\n        timespan = '{}/{}'.format(start_time, end_time)\n\n        return self.run_kql_query(query=query, timespan=timespan, limit=limit).to_json()\n\n    @staticmethod\n    def _build_api_parameters(api_version=DEFAULT_API_VERSION, statuses=None, time_frame=None, severities=None,\n                              case_number=None, start_time=None, end_time=None, limit=None, asc=False, timespan=None,\n                              creation_time=None):\n        # type: (str, list, int, list, int, str, str, int, bool, str, datetime) -> object\n        \"\"\"\n        Method to build api parameters in URL\n        @param api_version: API VERSION\n        @param statuses: Statuses\n        @param time_frame: Time Frame\n        @param severities: Severities\n        @param case_number: Case Number\n        @param start_time: Start Time\n        @param end_time: End Time\n        @param limit: Limit\n        @param asc: Asc\n        @param timespan: Time Span\n        @param creation_time: Search for incidents with createdTimeUtc greater than given datetime\n        @return: API parameters\n        \"\"\"\n        params = {'api-version': api_version}\n        filter_params = []\n\n        if case_number:\n            filter_params.append('properties/caseNumber eq {}'.format(case_number))\n\n        if creation_time:\n            filter_params.append('properties/createdTimeUtc ge {}'.format(creation_time.strftime(TIME_FORMAT)))\n\n        elif time_frame:\n            time = datetime.utcnow() - timedelta(hours=time_frame)\n            filter_params.append('properties/createdTimeUtc ge {}'.format(time.strftime(TIME_FORMAT)))\n\n        if statuses:\n            statuses_filter_group = \" or \".join([\"properties/status eq '{}'\".format(x) for x in statuses])\n            filter_params.append(\"({})\".format(statuses_filter_group))\n\n        if severities:\n            severities_filter_group = \" or \".join([\"properties/severity eq '{}'\".format(x) for x in severities])\n            filter_params.append(\"({})\".format(severities_filter_group))\n\n        # Apply filtering in oData format\n\n        if filter_params:\n            params['$filter'] = \" and \".join(filter_params)\n\n        if asc:\n            params['$orderBy'] = 'properties/createdTimeUtc asc'\n\n        if limit:\n            params['$top'] = limit\n\n        if start_time:\n            params['startTime'] = start_time\n\n        if end_time:\n            params['endTime'] = end_time\n\n        if timespan:\n            params['timespan'] = timespan\n\n        return params\n\n    @staticmethod\n    def _filter_alert_rules(alert_rules, severities=None, types=None, tactics=None, only_enabled_rules=False, limit=None):\n        # type: (list, list, list, list, bool, int) -> [object]\n        \"\"\"\n        Client-Side alert rules filtering\n        @param alert_rules: Alert Rules before filtration\n        @param severities: Severities to filter\n        @param types: Types to filter\n        @param tactics: Tactics to filter\n        @param only_enabled_rules: Filter only enabled Alert Rules\n        @param limit: Alert Rules to return\n        @return: Filtered Alert Rules\n        \"\"\"\n        filtered_alert_rules = []\n\n        for alert_rule in alert_rules:\n            conditions = []\n\n            if severities:\n                conditions += [\n                    alert_rule.properties and\n                    alert_rule.properties.severity and\n                    alert_rule.properties.severity in severities\n                ]\n\n            if types:\n                conditions += [\n                    alert_rule.kind and\n                    alert_rule.kind in types\n                ]\n\n            if tactics:\n                conditions += [\n                    alert_rule.properties and\n                    alert_rule.properties.tactics and\n                    any([tactic in tactics for tactic in alert_rule.properties.tactics])\n                ]\n\n            if only_enabled_rules:\n                conditions += [\n                    alert_rule.properties and\n                    alert_rule.properties.enabled\n                ]\n\n            if all(conditions):\n                filtered_alert_rules.append(alert_rule)\n\n        return filtered_alert_rules[:limit]\n\n    @staticmethod\n    def _filter_custom_hunting_rules(custom_hunting_rules, names=None, tactics=None):\n        # type: (list, list, list) -> [object]\n        \"\"\"\n        Client-Side Custom Hunting Rules filtering\n        @param custom_hunting_rules: Custom Hunting Rules before filtration\n        @param names: Names to filter\n        @param tactics: Tactics to filter\n        @return: Filtered Custom Hunting Rule\n        \"\"\"\n        filtered_custom_hunting_rules = []\n\n        for custom_hunting_rule in custom_hunting_rules:\n            conditions = []\n\n            if names:\n                conditions += [\n                    custom_hunting_rule.properties and\n                    custom_hunting_rule.properties.display_name and\n                    custom_hunting_rule.properties.display_name in names\n                ]\n\n            if tactics:\n                conditions += [\n                    custom_hunting_rule.properties and\n                    custom_hunting_rule.properties.tactics and\n                    any([tactic in tactics for tactic in custom_hunting_rule.properties.tactics])\n                ]\n\n            if all(conditions):\n                filtered_custom_hunting_rules.append(custom_hunting_rule)\n\n        return filtered_custom_hunting_rules\n\n    @staticmethod\n    def validate_login_response(response, error_msg=\"An error occurred\"):\n        # type: (requests.Response, str) -> None\n        \"\"\"\n        Login Response Validation\n        @param response: API Response\n        @param error_msg: Error message to change raised one\n        \"\"\"\n        try:\n            response.raise_for_status()\n\n        except requests.HTTPError as error:\n            raise MicrosoftAzureSentinelManagerError(\n                \"{error_msg}: {error} {text}\".format(\n                    error_msg=error_msg,\n                    error=error,\n                    text=response.json().get(\"error_description\", response.content)\n                )\n            )\n\n    @staticmethod\n    def validate_iso8601_duration(duration):\n        # type: (str) -> None or MicrosoftAzureSentinelValidationError\n        \"\"\"\n        Validate iso8601 duration\n        @param duration: Duration in ISO8601 format\n        \"\"\"\n        if not duration:\n            return\n\n        try:\n            isodate.parse_duration(duration)\n        except isodate.ISO8601Error:\n            raise MicrosoftAzureSentinelValidationError(f'Time duration format \\\"{duration}\\\" is invalid')\n\n    @classmethod\n    def validate_duration(cls, duration):\n        try:\n            if not duration:\n                return\n\n            duration = isodate.parse_duration(duration)\n\n            # In case we are using more than month duration, isodate.parse_duration returns Duration type\n            if not isinstance(duration, timedelta):\n                # Start time to use totimedelta function to calculate days in month to properly get total_seconds\n                duration = duration.totimedelta(datetime.utcnow())\n\n            if not MIN_PT_DURATION.total_seconds() <= duration.total_seconds() <= MAX_PT_DURATION.total_seconds():\n                raise MicrosoftAzureSentinelValidationError(\n                    f'Duration can be only between {MIN_PT_DURATION} and {MAX_PT_DURATION}\\n')\n        except isodate.ISO8601Error:\n            raise MicrosoftAzureSentinelValidationError('Time duration format \\\"{}\\\" is invalid'.format(duration))\n\n    @classmethod\n    def validate_sequence(cls, items, default, sec_name):\n        # type: (list, list, str) -> None or MicrosoftAzureSentinelValidationError\n        \"\"\"\n        Validate if statuses are a possible values\n        @param items: items ti validate\n        @param default: acceptable items\n        @param sec_name: acceptable items\n        \"\"\"\n        if not items:\n            return\n\n        items = set(items)\n        default_statuses = set(default)\n        wrong_statuses = items ^ default_statuses & items\n        if wrong_statuses:\n            raise MicrosoftAzureSentinelValidationError(\n                f'Wrong {sec_name} {convert_list_to_comma_separated_string(wrong_statuses)}.\\nPossible values '\n                f'are {convert_list_to_comma_separated_string(default_statuses)}')\n\n    @classmethod\n    def validate_statuses(cls, statuses, additional_defaults=None):\n        cls.validate_sequence(statuses, DEFAULT_STATUSES + (additional_defaults or []), 'statuses')\n\n    @classmethod\n    def validate_incident_statuses(cls, statuses, additional_defaults=None):\n        cls.validate_sequence(statuses, DEFAULT_UPDATE_INCIDENT_STATUSES + (additional_defaults or []), 'statuses')\n\n    @classmethod\n    def validate_severities(cls, severities, additional_defaults=None):\n        cls.validate_sequence(severities, DEFAULT_SEVERITIES + (additional_defaults or []), 'severities')\n\n    @classmethod\n    def validate_alert_rule_severities(cls, severities, additional_defaults=None):\n        cls.validate_sequence(severities, DEFAULT_ALERT_RULE_SEVERITIES + (additional_defaults or []), 'severities')\n\n    @classmethod\n    def validate_tactics(cls, tactics, additional_defaults=None):\n        cls.validate_sequence(tactics, DEFAULT_TACTICS + (additional_defaults or []), 'tactics')\n\n    @classmethod\n    def validate_trigger_operators(cls, trigger_operators, additional_defaults=None):\n        cls.validate_sequence(trigger_operators, DEFAULT_TRIGGER_OPERATORS + (additional_defaults or []), 'trigger')\n\n    @classmethod\n    def validate_close_reasons(cls, close_reasons, additional_defaults=None):\n        cls.validate_sequence(close_reasons, DEFAULT_CLOSE_REASONS + (additional_defaults or []), 'close_reasons')\n\n    # @TODO remove after refactor\n    @staticmethod\n    def convert_comma_separated_to_list(comma_separated):\n        # type: (str) -> list\n        \"\"\"\n        Convert comma-separated string to list\n        @param comma_separated: String with comma-separated values\n        @return: List of values\n        \"\"\"\n        return [item.strip() for item in comma_separated.split(',')] if comma_separated else []\n\n    @staticmethod\n    def join_validation_errors(validation_errors):\n        # type: (list) -> str\n        \"\"\"\n        Join validation errors list to one string\n        @param validation_errors: Validation error messages list\n        \"\"\"\n        return '\\n'.join(validation_errors)\n\n    @staticmethod\n    def convert_list_to_comma_separated_string(iterable):\n        # type: (list or set) -> str\n        \"\"\"\n        Convert list to comma separated string\n        @param iterable: List or Set to covert\n        \"\"\"\n        return ', '.join(iterable)\n    \n    def get_incident_comments(self, incident_number):\n        params = {\n            'api-version': self._get_endpoint_version('incident_comments'),\n        }\n        endpoint = API_ENDPOINTS[\"incident_comments\"][\"url\"].format(incident_number)\n        url = f'{self.base_url}{endpoint}'\n        response = self.session.get(url, params=params)\n        \n        return response.json()[\"value\"]\n        \n        \n    \n    def get_updated_incidents(self, updated_time=None, limit=None):\n        # type: (datetime, int, list, list, int, bool) -> [object]\n        \"\"\"\n        Get all Incidents including filters\n        @param updated_time: Get incidents with updatedUtc time greater than passed datetime\n        \"\"\"\n        params = {\n            'api-version': self._get_endpoint_version('incidents'),\n        }\n        \n\n        query = f\"(properties/lastModifiedTimeUtc ge {updated_time.strftime(TIME_FORMAT)} and properties/lastModifiedTimeUtc ne properties/createdTimeUtc)\"\n        \n        if query:\n            params[QueryFilterKeyEnum.FILTER.value] = query\n        \n        if limit:\n            params[QueryFilterKeyEnum.LIMIT.value] = limit\n\n        response = self.session.get(self._get_full_url('incidents'), params=params)\n        self.validate_response(response)\n        return self.sentinel_parser.build_results(response.json(), 'build_siemplify_incident_obj', limit=limit)\n    \n    def get_incident_entities(self, alert_id, incident_number, incident_id, backlog_ids):\n        \"\"\"\n        Get Azure Sentinel entities related to specific incident.\n        :param alert_id: {str} Id of the alert\n        :param incident_number: {int} The number of the incident\n        :param incident_id: {str} ID of the incident\n        :param backlog_ids: {dict} Backlog ids dict\n        :return: {list} List of Entity objects\n        \"\"\"\n        url = '{}{}'.format(self.base_url, API_ENDPOINTS['GET_INCIDENT_ENTITIES']['URL'].format(incident_id=incident_id))\n\n        params = {\n            'api-version': API_ENDPOINTS['GET_INCIDENT_ENTITIES']['VERSION']\n        }\n\n        response = self.session.post(url, params=params)\n\n        try:\n            self.validate_response(response)\n        except Exception as e:\n            if isinstance(e, MicrosoftAzureSentinelTimeoutError):\n                raise\n            if incident_number not in backlog_ids:\n                self.logger.error(\"Failed to fetch alert {} entities. Will send it to backlog. Incident {}\".\n                                  format(alert_id, incident_id))\n            return None\n\n        response_data = response.json()\n        edges_data = response_data.get('edges', [])\n\n        return [self.sentinel_parser.build_siemplify_alert_entity_obj(\n                    entity_data,\n                    next((edge.get('additionalData', {}) for edge in edges_data\n                         if edge.get('targetEntityId') == entity_data.get('id')), None)\n                ) for entity_data in response_data.get('entities', [])]\n    \n    def get_incident_entities_sync(self, incident_id):\n        \"\"\"\n        Get Azure Sentinel entities related to specific incident.\n        :param alert_id: {str} Id of the alert\n        :param incident_number: {int} The number of the incident\n        :param incident_id: {str} ID of the incident\n        :param backlog_ids: {dict} Backlog ids dict\n        :return: {list} List of Entity objects\n        \"\"\"\n        url = '{}{}'.format(self.base_url, API_ENDPOINTS['GET_INCIDENT_ENTITIES']['URL'].format(incident_id=incident_id))\n\n        params = {\n            'api-version': API_ENDPOINTS['GET_INCIDENT_ENTITIES']['VERSION']\n        }\n\n        response = self.session.post(url, params=params)\n\n        try:\n            self.validate_response(response)\n        except Exception as e:\n            if isinstance(e, MicrosoftAzureSentinelTimeoutError):\n                raise\n            \n            return None\n\n        response_data = response.json()\n        edges_data = response_data.get('edges', [])\n        \n        return [self.sentinel_parser.build_siemplify_alert_entity_obj(\n                    entity_data,\n                    next((edge.get('additionalData', {}) for edge in edges_data\n                         if edge.get('targetEntityId') == entity_data.get('id')), None)\n                ) for entity_data in response_data.get('entities', [])]\n",
    "integration": "MicrosoftAzureSentinel",
    "creator": "7a7f9e2c-7774-4221-8558-986f5708fd17",
    "creatorFullName": "jose marin",
    "isEnabled": true,
    "isCustom": true,
    "version": 2,
    "parameters": [],
    "connectorRules": null,
    "isConnectorRulesSupported": false,
    "documentationLink": null,
    "pythonVersion": "V3_7"
}