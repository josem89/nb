{
    "id": 0,
    "type": 4,
    "name": "JinjaFilters2",
    "description": null,
    "script": "import json\nimport dateutil\nimport time\nimport re\nimport six\nfrom json2table import convert\nfrom json2html import *\nimport datetime\nimport copy\n\n\nclass DotAccessibleDict:\n    reserved = ['self']\n\n    def __init__(self, **kwargs):\n        for key, val in kwargs.items():\n            if key in self.reserved:\n                # in our case, we have a key in dict which is \"self\", and it would cause problems while parsing\n                key = f'_{key}'\n            if type(val) == dict:\n                setattr(self, key, DotAccessibleDict(**val))\n            elif type(val) == list:\n                setattr(self, key, [DotAccessibleDict(**el) if isinstance(el, dict) else el for el in val])\n            else:\n                setattr(self, key, val)\n\n    def get(self, index):\n        target = self\n        parts = index.split('.')\n        for i in parts:\n            if isinstance(target, list):\n                target = target[0]\n            target = getattr(target, i)\n        return target\n\n    def set(self, index, value):\n        if index:\n            parts = index.split('.')\n            tmp_obj = getattr(self, parts[0]) if hasattr(self, parts[0]) else DotAccessibleDict()\n            if len(parts) > 1:\n                tmp_obj.set('.'.join(parts[1:]), value)\n            else:\n                tmp_obj = value\n            setattr(self, parts[0], tmp_obj)\n        return self\n\n    def filter(self, fields):\n        new_dict = DotAccessibleDict()\n        for field in fields:\n            new_dict.set(field, self.get(field))\n        return new_dict\n\n    def to_dict(self):\n        obj = {}\n        for i in self.__dict__:\n            val = getattr(self, i)\n            if isinstance(val, DotAccessibleDict):\n                obj[i] = val.to_dict()\n            elif isinstance(val, list):\n                obj[i] = [el.to_dict() if isinstance(el, DotAccessibleDict) else el for el in val]\n            else:\n                obj[i] = val\n        return obj\n\n\ndef json2tbl(json_object, build_direction=\"LEFT_TO_RIGHT\", table_attributes=None):\n    \"\"\"\n    JSON 2 Table\n    Converts a JSON object into an HTML table.  Chain the results of this filter to |safe to remove HTML encoding.\n    :param json_object: {dict or list} JSON object to convert into HTML.\n    :param build_direction: {unicode} String denoting the build direction of the table. Only supports dict input json_objects.\n                            If \"TOP_TO_BOTTOM\" child objects will be appended below parents, i.e. in the subsequent row.\n                            If \"LEFT_TO_RIGHT\" child objects will be appended to the right of parents, i.e. in the subsequent column.\n                            Default is \"LEFT_TO_RIGHT\". {\"TOP_TO_BOTTOM\", \"LEFT_TO_RIGHT\"}\n    :param table_attributes: {dict} Dictionary of (key, value) pairs describing attributes to add to the table. Each\n                            attribute is added according to the template key=\"value\". For example, the table { \"border\" : 1 }\n                            modifies the generated table tags to include border=\"1\" as an attribute.\n                            The generated opening tag would look like <table border=\"1\">.\n                            Only supports \"class\" attribute for input json_object of list type.\n                            Default is None.\n    :return: {str} String of converted HTML.\n    \"\"\"\n    if isinstance(json_object, dict):\n        return convert(json_object, build_direction=build_direction, table_attributes=table_attributes)\n    if isinstance(json_object, list):\n        if table_attributes and 'class' in table_attributes:\n            return json2html.convert(json=json_object, table_attributes=f\"class=\\\"{table_attributes['class']}\\\"\")\n        return json2html.convert(json=json_object)\n\n\ndef to_json(a, *args, **kw):\n    ''' Convert the value to JSON '''\n    return json.dumps(a, *args, **kw)\n\n\ndef to_nice_json(a, indent=4, sort_keys=True, *args, **kw):\n    '''Make verbose, human readable JSON'''\n    return to_json(a, indent=indent, sort_keys=sort_keys, separators=(',', ': '), *args, **kw)\n\n\ndef is_in_list(val, in_list):\n    return True if val in in_list else False\n\n\ndef _get_regex_flags(ignorecase=False):\n    return re.I if ignorecase else 0\n\n\ndef regex_match(value, pattern, ignorecase=False):\n    if not isinstance(value, six.string_types):\n        value = str(value)\n    flags = _get_regex_flags(ignorecase)\n    return bool(re.match(pattern, value, flags))\n\n\ndef regex_replace(value, pattern, replacement, ignorecase=False):\n    if not isinstance(value, six.string_types):\n        value = str(value)\n    flags = _get_regex_flags(ignorecase)\n    regex = re.compile(pattern, flags)\n    return regex.sub(replacement, value)\n\n\ndef regex_search(value, pattern, ignorecase=False):\n    if not isinstance(value, six.string_types):\n        value = str(value)\n    flags = _get_regex_flags(ignorecase)\n    return bool(re.search(pattern, value, flags))\n\n\ndef regex_substring(value, pattern, result_index=0, ignorecase=False):\n    if not isinstance(value, six.string_types):\n        value = str(value)\n    flags = _get_regex_flags(ignorecase)\n    return re.findall(pattern, value, flags)[result_index]\n\n\ndef filter_datetime(date, fmt=\"%Y/%m/%d %H:%M:%S\"):\n    try:\n        if len(str(int(date))) == 13:\n            ts = int(date) / 1000\n            date = datetime.datetime.fromtimestamp(ts)\n        elif len(str(int(date))) == 9 or len(str(int(date))) == 10:\n            date = datetime.datetime.fromtimestamp(int(date))\n        else:\n            date = dateutil.parser.parse(date)\n    except:\n        date = dateutil.parser.parse(date)\n\n    return date.strftime(fmt)\n\n\ndef map_priority(p):\n    PRIORITY = {\n        '-1': 'info',\n        '40': 'low',\n        '60': 'medium',\n        '80': 'high',\n        '100': 'critical'\n    }\n    return PRIORITY.get(p)\n\n\ndef timectime(s):\n    a_str = str(s)\n    if len(a_str) == 13:\n        s = s / 1000\n    # return datetime.datetime.fromtimestamp(int(s))\n    return time.ctime(int(s))  # datetime.datetime.fromtimestamp(s)\n\ndef dedup_list_of_dicts(list_of_dicts):\n    '''This dedups a list of dictionaries. It checks to see if the key/values are the same'''\n    seen = set()\n    new_l = []\n    for d in list_of_dicts:\n        t = tuple(d.items())\n        if t not in seen:\n            seen.add(t)\n            new_l.append(d)\n    return new_l\n\ndef ternary(value, true_val, false_val, none_val=None):\n    '''  value ? true_val : false_val '''\n    if value is None and none_val is not None:\n        return none_val\n    elif bool(value):\n        return true_val\n    else:\n        return false_val\n\n\ndef comment(text, style='plain', **kw):\n    # Predefined comment types\n    comment_styles = {\n        'plain': {\n            'decoration': '# '\n        },\n        'erlang': {\n            'decoration': '% '\n        },\n        'c': {\n            'decoration': '// '\n        },\n        'cblock': {\n            'beginning': '/*',\n            'decoration': ' * ',\n            'end': ' */'\n        },\n        'xml': {\n            'beginning': '<!--',\n            'decoration': ' - ',\n            'end': '-->'\n        }\n    }\n\n    # Pointer to the right comment type\n    style_params = comment_styles[style]\n\n    if 'decoration' in kw:\n        prepostfix = kw['decoration']\n    else:\n        prepostfix = style_params['decoration']\n\n    # Default params\n    p = {\n        'newline': '\\n',\n        'beginning': '',\n        'prefix': (prepostfix).rstrip(),\n        'prefix_count': 1,\n        'decoration': '',\n        'postfix': (prepostfix).rstrip(),\n        'postfix_count': 1,\n        'end': ''\n    }\n\n    # Update default params\n    p.update(style_params)\n    p.update(kw)\n\n    # Compose substrings for the final string\n    str_beginning = ''\n    if p['beginning']:\n        str_beginning = \"%s%s\" % (p['beginning'], p['newline'])\n    str_prefix = ''\n    if p['prefix']:\n        if p['prefix'] != p['newline']:\n            str_prefix = str(\n                \"%s%s\" % (p['prefix'], p['newline'])) * int(p['prefix_count'])\n        else:\n            str_prefix = str(\n                \"%s\" % (p['newline'])) * int(p['prefix_count'])\n    str_text = (\"%s%s\" % (\n        p['decoration'],\n        # Prepend each line of the text with the decorator\n        text.replace(\n            p['newline'], \"%s%s\" % (p['newline'], p['decoration'])))).replace(\n        # Remove trailing spaces when only decorator is on the line\n        \"%s%s\" % (p['decoration'], p['newline']),\n        \"%s%s\" % (p['decoration'].rstrip(), p['newline']))\n    str_postfix = p['newline'].join(\n        [''] + [p['postfix'] for x in range(p['postfix_count'])])\n    str_end = ''\n    if p['end']:\n        str_end = \"%s%s\" % (p['newline'], p['end'])\n\n    # Return the final string\n    return \"%s%s%s%s%s\" % (\n        str_beginning,\n        str_prefix,\n        str_text,\n        str_postfix,\n        str_end)\n\ndef filter_json(json_object, include_keys):\n    # include_keys is a comma separated list of key paths in a json object.\n    # using . as the separator between nested keys.\n    dynamic_object = DotAccessibleDict(**json_object)\n    filter_keys = include_keys.split(\",\")\n    filtered = dynamic_object.filter(filter_keys)\n    return filtered.to_dict()\n\ndef arrayToHtmlTable(in_array):\n    if hasattr(in_array, '__len__') and (not isinstance(in_array, str)):\n        return in_array \n\ndef epochTimeToHuman(epoch_time):\n    epoch_time = int(epoch_time) / 1000\n    human_time = time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(epoch_time))\n    return(str(human_time))\n\n\n",
    "integration": "TemplateEngine",
    "creator": "7a7f9e2c-7774-4221-8558-986f5708fd17",
    "creatorFullName": "jose marin",
    "isEnabled": true,
    "isCustom": true,
    "version": 0,
    "parameters": [],
    "connectorRules": null,
    "isConnectorRulesSupported": false,
    "documentationLink": null,
    "pythonVersion": "V3_7"
}